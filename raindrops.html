<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>RAINDROPS</title>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: sans-serif;
            padding: 20px;
        }
        canvas {
            border: 2px solid #555;
            border-radius: 8px;
            cursor: crosshair;
        }
        .mode-buttons {
            margin-top: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        .mode-button {
            padding: 8px 15px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .mode-button.active {
            background-color: #007bff;
        }
        .controls-container {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }
        .controls {
            width: 400px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }
        .point-control {
            margin: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .point-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .point-label {
            min-width: 60px;
        }
        input[type="range"] {
            flex: 1;
        }
        #save-btn, #reset-rect-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        #save-btn:hover, #reset-rect-btn:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <h3>切換模式以進行操作</h3>
    <div class="mode-buttons">
        <button id="full-canvas-mode-btn" class="mode-button active">全畫布</button>
        <button id="rect-mode-btn" class="mode-button">矩形模式</button>
    </div>

    <canvas id="canvas" width="1280" height="720"></canvas>
    <a id="save-btn" href="#">儲存圖片</a>
    <button id="reset-rect-btn" style="display: none;">重設所有矩形</button>

    <div class="controls-container">
        <div class="controls" id="points-controls">
            <h4>控制點屬性</h4>
            <div id="controls"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const w = canvas.width;
        const h = canvas.height;
        const controlsDiv = document.getElementById("controls");
        const saveBtn = document.getElementById("save-btn");
        const fullCanvasModeBtn = document.getElementById("full-canvas-mode-btn");
        const rectModeBtn = document.getElementById("rect-mode-btn");
        const resetRectBtn = document.getElementById("reset-rect-btn");

        let globalPoints = [];
        let draggingPoint = null;
        let selectedPoint = null;
        let pointIdCounter = 0;

        let rectangles = [];
        const RECT_COUNT = 50;
        let selectedRectId = null;

        let currentMode = 'full';
        
        function initializeGlobalPoints() {
            pointIdCounter = 0; 
            globalPoints = [
                { x: 0, y: h / 2, gray: 255, alpha: 255, id: pointIdCounter++ }, 
                { x: w, y: h / 2, gray: 0, alpha: 255, id: pointIdCounter++ } 
            ];
            if (globalPoints.length > 0) {
                selectedPoint = globalPoints[0];
            }
        }

        function initializeRectangles() {
            if (rectangles.length === 0) {
                const rectHeight = h / RECT_COUNT;
                for (let i = 0; i < RECT_COUNT; i++) {
                    const rectY = i * rectHeight;
                    const rectMidY = rectY + rectHeight / 2;
                    const newRectObj = {
                        id: i,
                        rectStart: { x: 0, y: rectY },
                        rectEnd: { x: w, y: rectY + rectHeight },
                        linearGradientPoints: [
                            { x: 0, y: rectMidY, gray: 255, alpha: 255, id: pointIdCounter++ }, 
                            { x: w, y: rectMidY, gray: 0, alpha: 255, id: pointIdCounter++ } 
                        ]
                    };
                    rectangles.push(newRectObj);
                }
            }
        }

        function calculateLinearGradientWithAlpha(points, x, y) {
            if (points.length === 0) {
                return { gray: 0, alpha: 0 };
            }
            if (points.length === 1) {
                return { gray: points[0].gray, alpha: points[0].alpha };
            }
            
            const sortedByX = points.slice().sort((a, b) => a.x - b.x);
            const pStartLine = sortedByX[0];
            const pEndLine = sortedByX[sortedByX.length - 1];

            const dxLine = pEndLine.x - pStartLine.x;
            const dyLine = pEndLine.y - pStartLine.y;
            const lenSqLine = dxLine * dxLine + dyLine * dyLine;
            
            let t = 0;
            if (lenSqLine > 0) {
                t = ((x - pStartLine.x) * dxLine + (y - pStartLine.y) * dyLine) / lenSqLine;
            }

            const sortedPoints = points.map(p => {
                const p_t = lenSqLine > 0 ? (((p.x - pStartLine.x) * dxLine + (p.y - pStartLine.y) * dyLine) / lenSqLine) : (p.x / w);
                return { ...p, t: p_t };
            }).sort((a, b) => a.t - b.t);

            let gray, alpha;

            if (t <= sortedPoints[0].t) {
                gray = sortedPoints[0].gray;
                alpha = sortedPoints[0].alpha;
            } 
            else if (t >= sortedPoints[sortedPoints.length - 1].t) {
                gray = sortedPoints[sortedPoints.length - 1].gray;
                alpha = sortedPoints[sortedPoints.length - 1].alpha;
            } 
            else {
                let pA, pB;
                for (let i = 0; i < sortedPoints.length - 1; i++) {
                    if (t >= sortedPoints[i].t && t <= sortedPoints[i + 1].t) {
                        pA = sortedPoints[i];
                        pB = sortedPoints[i + 1];
                        
                        const segmentLength = pB.t - pA.t;
                        const localT = (segmentLength > 0) ? (t - pA.t) / segmentLength : 0;

                        gray = pA.gray * (1 - localT) + pB.gray * localT;
                        alpha = pA.alpha * (1 - localT) + pB.alpha * localT;
                        break;
                    }
                }
                if (typeof gray === 'undefined') { // Fallback for floating point inaccuracies
                    gray = sortedPoints[sortedPoints.length - 1].gray;
                    alpha = sortedPoints[sortedPoints.length - 1].alpha;
                }
            }
            
            return { gray, alpha };
        }

        function drawField(isForSave = false) {
            let imgData = ctx.createImageData(w, h);
            let data = imgData.data;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    
                    // Always calculate the full-canvas background gradient
                    const { gray: bgGray, alpha: bgAlpha } = calculateLinearGradientWithAlpha(globalPoints, x, y);

                    let finalGray, finalAlpha;
                    
                    // Find if the current pixel is inside a modified rectangle
                    const rectHeight = h / RECT_COUNT;
                    const rectIndex = Math.floor(y / rectHeight);
                    const currentRect = rectangles[rectIndex];

                    // If the rect has been modified (more than 2 points), use its gradient.
                    if (currentRect && currentRect.linearGradientPoints.length > 2) {
                        const { gray: rectGray, alpha: rectAlpha } = calculateLinearGradientWithAlpha(currentRect.linearGradientPoints, x, y);
                        
                        // Blend the rectangle's gradient with the background
                        const blendFactor = rectAlpha / 255;
                        finalGray = rectGray * blendFactor + bgGray * (1 - blendFactor);
                        finalAlpha = rectAlpha + bgAlpha * (1 - blendFactor);
                    } else {
                        // Otherwise, just use the background gradient
                        finalGray = bgGray;
                        finalAlpha = bgAlpha;
                    }

                    data[idx] = data[idx + 1] = data[idx + 2] = Math.max(0, Math.min(255, finalGray));
                    data[idx + 3] = Math.max(0, Math.min(255, finalAlpha)); 
                }
            }
            ctx.putImageData(imgData, 0, 0);

            if (!isForSave) {
                let pointsToDraw = [];

                if (currentMode === 'full') {
                    pointsToDraw = globalPoints;
                    if (pointsToDraw.length > 1) {
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const sortedByX = pointsToDraw.slice().sort((a,b)=>a.x-b.x);
                        ctx.moveTo(sortedByX[0].x, sortedByX[0].y);
                        for (let i = 1; i < sortedByX.length; i++) {
                            ctx.lineTo(sortedByX[i].x, sortedByX[i].y);
                        }
                        ctx.stroke();
                    }
                    pointsToDraw.forEach(p => drawPoint(p, (draggingPoint && draggingPoint.id === p.id)));
                } else if (currentMode === 'rect' && selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    if (selectedRect) {
                        const rectX = Math.min(selectedRect.rectStart.x, selectedRect.rectEnd.x);
                        const rectY = Math.min(selectedRect.rectStart.y, selectedRect.rectEnd.y);
                        const rectW = Math.abs(selectedRect.rectEnd.x - selectedRect.rectStart.x);
                        const rectH = Math.abs(selectedRect.rectEnd.y - selectedRect.rectStart.y);
                        
                        ctx.strokeStyle = "rgba(255, 255, 0, 0.5)";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(rectX, rectY, rectW, rectH);

                        pointsToDraw = selectedRect.linearGradientPoints;
                        if (pointsToDraw.length > 1) {
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            const sortedPointsForDrawing = pointsToDraw.slice().sort((a, b) => a.x - b.x);
                            ctx.moveTo(sortedPointsForDrawing[0].x, sortedPointsForDrawing[0].y);
                            for (let i = 1; i < sortedPointsForDrawing.length; i++) {
                                ctx.lineTo(sortedPointsForDrawing[i].x, sortedPointsForDrawing[i].y);
                            }
                            ctx.stroke();
                        }
                        pointsToDraw.forEach(p => drawPoint(p, (draggingPoint && draggingPoint.id === p.id)));
                    }
                }
            }
        }

        function drawPoint(p, isDragging) {
            ctx.fillStyle = `rgba(${p.gray}, ${p.gray}, ${p.gray}, ${p.alpha / 255})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "red";
            ctx.lineWidth = isDragging ? 3 : 1;
            ctx.stroke();
        }

        function updateControls() {
            controlsDiv.innerHTML = '';
            if (currentMode === 'full' && selectedPoint) {
                const labelText = `點 ${selectedPoint.id}`;
                createPointControl(selectedPoint, labelText);
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                if (selectedPoint) {
                   createPointControl(selectedPoint, `區域 ${selectedRectId} 點 ${selectedPoint.id}`);
                }
            }
        }

        function createPointControl(p, labelText) {
            const wrapper = document.createElement("div");
            wrapper.className = "point-control";
            wrapper.dataset.pointId = p.id;

            const label = document.createElement("span");
            label.className = "point-label";
            label.textContent = `${labelText} (${Math.floor(p.x)},${Math.floor(p.y)})`;
            wrapper.appendChild(label);

            const grayRow = document.createElement("div");
            grayRow.className = "point-control-row";
            const grayLabel = document.createElement("span");
            grayLabel.textContent = "灰度:";
            const graySlider = document.createElement("input");
            graySlider.type = "range";
            graySlider.min = 0;
            graySlider.max = 255;
            graySlider.value = p.gray;
            graySlider.title = "灰度";
            graySlider.oninput = () => {
                p.gray = parseInt(graySlider.value);
                drawField();
            };
            grayRow.appendChild(grayLabel);
            grayRow.appendChild(graySlider);
            wrapper.appendChild(grayRow);
            
            const alphaRow = document.createElement("div");
            alphaRow.className = "point-control-row";
            const alphaLabel = document.createElement("span");
            alphaLabel.textContent = "透明度:";
            const alphaSlider = document.createElement("input");
            alphaSlider.type = "range";
            alphaSlider.min = 0;
            alphaSlider.max = 255;
            alphaSlider.value = p.alpha;
            alphaSlider.title = "透明度";
            alphaSlider.oninput = () => {
                p.alpha = parseInt(alphaSlider.value);
                drawField();
            };
            alphaRow.appendChild(alphaLabel);
            alphaRow.appendChild(alphaSlider);
            wrapper.appendChild(alphaRow);
            
            controlsDiv.appendChild(wrapper);
        }

        function setMode(mode) {
            currentMode = mode;
            fullCanvasModeBtn.classList.toggle('active', mode === 'full');
            rectModeBtn.classList.toggle('active', mode === 'rect');

            selectedPoint = null; 
            selectedRectId = null;
            
            if (mode === 'full') {
                resetRectBtn.style.display = 'none';
                document.querySelector('h3').textContent = '全畫布模式 (線性漸變)：左右兩點固定，僅可上下移動。左鍵點擊新增點，右鍵刪除中途點。';
            } else {
                resetRectBtn.style.display = 'none';
                document.querySelector('h3').textContent = '矩形模式：點擊一個區域以選取它，然後點擊區域內以新增或選取點，右鍵刪除非固定點。';
            }
            updateControls();
            drawField(); 
        }

        saveBtn.addEventListener("click", () => {
            drawField(true);
            const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
            saveBtn.setAttribute("href", image);
            saveBtn.setAttribute("download", "grayscale_gradient.png");
            drawField();
        });

        fullCanvasModeBtn.addEventListener("click", () => {
            setMode('full');
        });

        rectModeBtn.addEventListener("click", () => {
            setMode('rect');
        });
        
        let didDrag = false;

        canvas.addEventListener("mousedown", e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            didDrag = false;
            
            if (currentMode === 'full') {
                let foundPoint = null;
                for (let i = 0; i < globalPoints.length; i++) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }

                if (e.button === 0) {
                    if (foundPoint) {
                        draggingPoint = foundPoint;
                        selectedPoint = foundPoint;
                        canvas.style.cursor = "move";
                    } else {
                        const newPoint = { x: mouseX, y: mouseY, gray: 128, alpha: 255, id: pointIdCounter++ };
                        globalPoints.push(newPoint);
                        selectedPoint = newPoint;
                    }
                }
                
                updateControls();
                drawField();
                return;
            }

            if (currentMode === 'rect') {
                const rectHeight = h / RECT_COUNT;
                const rectIndex = Math.floor(mouseY / rectHeight);
                const rectObj = rectangles[rectIndex];

                if (rectObj) {
                    selectedRectId = rectObj.id;
                    const rectPoints = rectObj.linearGradientPoints;
                    
                    let foundPointToDrag = null;
                    for (let i = 0; i < rectPoints.length; i++) {
                        const p = rectPoints[i];
                        const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                        if (dist < 10) {
                            foundPointToDrag = p;
                            break;
                        }
                    }

                    if (foundPointToDrag) {
                        draggingPoint = foundPointToDrag;
                        selectedPoint = foundPointToDrag;
                        canvas.style.cursor = "move";
                    } else {
                        const newPoint = { x: mouseX, y: rectPoints[0].y, gray: 128, alpha: 255, id: pointIdCounter++ };
                        rectPoints.push(newPoint);
                        selectedPoint = newPoint;
                    }
                    updateControls();
                    drawField();
                } else {
                    selectedRectId = null;
                    selectedPoint = null;
                    updateControls();
                    drawField();
                }
            }
        });

        canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (draggingPoint) {
                didDrag = true;
                if (currentMode === 'full') {
                    if (draggingPoint.id === 0) {
                        draggingPoint.y = mouseY; 
                        draggingPoint.x = 0; 
                    } else if (draggingPoint.id === 1) {
                        draggingPoint.y = mouseY; 
                        draggingPoint.x = w; 
                    } else {
                        draggingPoint.x = mouseX;
                        draggingPoint.y = mouseY;
                    }
                } else if (currentMode === 'rect' && selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    const isFixedPoint = selectedRect.linearGradientPoints.some(p => p.id === draggingPoint.id && (p.x === 0 || p.x === w));
                    
                    if (!isFixedPoint) {
                        draggingPoint.x = Math.max(0, Math.min(mouseX, w));
                    }
                    draggingPoint.y = selectedRect.linearGradientPoints[0].y;
                } 
                updateControls();
                drawField();
            }
        });

        canvas.addEventListener("mouseup", e => {
            draggingPoint = null;
            canvas.style.cursor = "crosshair";
            if (didDrag) {
                e.stopImmediatePropagation();
                didDrag = false;
            }
        });

        canvas.addEventListener("click", e => {
            if (didDrag) {
                didDrag = false;
                return;
            }
            if (currentMode === 'full') {
                 let foundPoint = null;
                for (let i = 0; i < globalPoints.length; i++) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((e.offsetX - p.x) ** 2 + (e.offsetY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }
                selectedPoint = foundPoint; 
                updateControls();
                drawField();
                return;
            }
            
            if (currentMode === 'rect' && selectedRectId !== null) {
                const selectedRect = rectangles.find(r => r.id === selectedRectId);
                const rectPoints = selectedRect.linearGradientPoints;
                let foundPoint = null;
                for (let i = 0; i < rectPoints.length; i++) {
                    const p = rectPoints[i];
                    const dist = Math.sqrt((e.offsetX - p.x) ** 2 + (e.offsetY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }
                selectedPoint = foundPoint; 
                updateControls();
                drawField();
            }
        });

        canvas.addEventListener("contextmenu", e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentMode === 'full') {
                for (let i = globalPoints.length - 1; i >= 0; i--) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                    if (dist < 10 && p.id > 1) { 
                        globalPoints.splice(i, 1);
                        if (selectedPoint && selectedPoint.id === p.id) {
                            selectedPoint = null;
                        }
                        updateControls();
                        drawField();
                        return;
                    }
                }
            } else if (currentMode === 'rect') {
                if (selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    const rectPoints = selectedRect.linearGradientPoints;
                    
                    for (let i = rectPoints.length - 1; i >= 0; i--) {
                        const p = rectPoints[i];
                        const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                        
                        const isFixedPoint = rectPoints.some(fp => fp.id === p.id && (fp.x === 0 || fp.x === w));
                        
                        if (dist < 10 && !isFixedPoint) {
                            rectPoints.splice(i, 1);
                            if (selectedPoint && selectedPoint.id === p.id) {
                                selectedPoint = null;
                            }
                            updateControls();
                            drawField();
                            return;
                        }
                    }
                }
            }
        });
        
        initializeGlobalPoints();
        initializeRectangles();
        setMode('full');
    </script>
</body>
</html>