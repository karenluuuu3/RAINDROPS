<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>RAINDROPS</title>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: sans-serif;
            padding: 20px;
        }
        canvas {
            border: 2px solid #555;
            border-radius: 8px;
            cursor: crosshair;
        }
        .mode-buttons {
            margin-top: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        .mode-button {
            padding: 8px 15px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .mode-button.active {
            background-color: #007bff;
        }
        .controls-container {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }
        .controls {
            width: 400px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }
        .point-control {
            margin: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .point-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .point-label {
            min-width: 60px;
        }
        input[type="range"] {
            flex: 1;
        }
        #save-btn, #reset-rect-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        #save-btn:hover, #reset-rect-btn:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <h3>切換模式以進行操作</h3>
    <div class="mode-buttons">
        <button id="full-canvas-mode-btn" class="mode-button active">全畫布</button>
        <button id="rect-mode-btn" class="mode-button">矩形模式</button>
    </div>

    <canvas id="canvas" width="1280" height="720"></canvas>
    <a id="save-btn" href="#">儲存圖片</a>
    <button id="reset-rect-btn" style="display: none;">重設所有矩形</button>

    <div class="controls-container">
        <div class="controls" id="points-controls">
            <h4>控制點屬性</h4>
            <div id="controls"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const w = canvas.width;
        const h = canvas.height;
        const controlsDiv = document.getElementById("controls");
        const saveBtn = document.getElementById("save-btn");
        const fullCanvasModeBtn = document.getElementById("full-canvas-mode-btn");
        const rectModeBtn = document.getElementById("rect-mode-btn");
        const resetRectBtn = document.getElementById("reset-rect-btn");

        let globalPoints = [];
        let draggingPoint = null;
        let selectedPoint = null;
        let pointIdCounter = 0;

        let rectangles = [];
        let drawingRect = false;
        let rectStart = null;
        let currentRect = null;
        let selectedRectId = null;
        let rectIdCounter = 0;

        let currentMode = 'full';
        
        function initializeGlobalPoints() {
            pointIdCounter = 0; 
            globalPoints = [
                { x: 0, y: h / 2, gray: 255, alpha: 255, id: pointIdCounter++ }, 
                { x: w, y: h / 2, gray: 0, alpha: 255, id: pointIdCounter++ } 
            ];
            if (globalPoints.length > 0) {
                selectedPoint = globalPoints[0];
            }
        }

        function calculateLinearGradientWithAlpha(points, x, y) {
            if (points.length === 0) {
                return { gray: 0, alpha: 0 };
            }
            if (points.length === 1) {
                return { gray: points[0].gray, alpha: points[0].alpha };
            }
            
            // 修正：針對矩形模式，漸變是基於水平距離
            const pStartLine = points.slice().sort((a, b) => a.x - b.x)[0];
            const pEndLine = points.slice().sort((a, b) => a.x - b.x)[points.length - 1];

            const dxLine = pEndLine.x - pStartLine.x;
            const dyLine = 0; // 垂直距離為0，因為點都在水平線上
            const lenSqLine = dxLine * dxLine + dyLine * dyLine;
            
            let t = 0;
            if (lenSqLine > 0) {
                t = ((x - pStartLine.x) * dxLine + (y - pStartLine.y) * dyLine) / lenSqLine;
            }

            const sortedPoints = points.slice().sort((a, b) => a.x - b.x);

            let gray, alpha;

            if (t <= 0) {
                gray = sortedPoints[0].gray;
                alpha = sortedPoints[0].alpha;
            } 
            else if (t >= 1) {
                gray = sortedPoints[sortedPoints.length - 1].gray;
                alpha = sortedPoints[sortedPoints.length - 1].alpha;
            } 
            else {
                for (let i = 0; i < sortedPoints.length - 1; i++) {
                    const pA = sortedPoints[i];
                    const pB = sortedPoints[i + 1];

                    const localT = (x - pA.x) / (pB.x - pA.x);
                    if (localT >= 0 && localT <= 1) {
                        gray = pA.gray * (1 - localT) + pB.gray * localT;
                        alpha = pA.alpha * (1 - localT) + pB.alpha * localT;
                        break;
                    }
                }
            }
            
            return { gray, alpha };
        }


        function drawField(isForSave = false) {
            let imgData = ctx.createImageData(w, h);
            let data = imgData.data;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    let finalGray, finalAlpha;
                    
                    let activeRect = null;
                    if (currentMode === 'rect') {
                        for (let i = rectangles.length - 1; i >= 0; i--) {
                            const rectObj = rectangles[i];
                            const rectX = Math.min(rectObj.rectStart.x, rectObj.rectEnd.x);
                            const rectY = Math.min(rectObj.rectStart.y, rectObj.rectEnd.y);
                            const rectW = Math.abs(rectObj.rectEnd.x - rectObj.rectStart.x);
                            const rectH = Math.abs(rectObj.rectEnd.y - rectObj.rectStart.y);

                            if (x >= rectX && x < rectX + rectW && y >= rectY && y < rectY + rectH) {
                                activeRect = rectObj;
                                break; 
                            }
                        }
                    }

                    if (activeRect) {
                        const { gray: rectGray, alpha: rectAlpha } = calculateLinearGradientWithAlpha(activeRect.linearGradientPoints, x, y);
                        const { gray: bgGray, alpha: bgAlpha } = calculateLinearGradientWithAlpha(globalPoints, x, y);
                        
                        const rectX = Math.min(activeRect.rectStart.x, activeRect.rectEnd.x);
                        const rectW = Math.abs(activeRect.rectEnd.x - activeRect.rectStart.x);

                        const smoothDist = activeRect.blendSmoothness;
                        const distFromLeft = x - rectX;
                        const distFromRight = (rectX + rectW) - x;

                        const edgeBlendFactor = Math.min(1, distFromLeft / smoothDist, distFromRight / smoothDist);
                        const finalBlendFactor = Math.max(0, Math.min(1, (rectAlpha / 255) * edgeBlendFactor));
                        
                        finalGray = bgGray * (1 - finalBlendFactor) + rectGray * finalBlendFactor;
                        finalAlpha = bgAlpha; 
                    } else {
                        const { gray, alpha } = calculateLinearGradientWithAlpha(globalPoints, x, y);
                        finalGray = gray;
                        finalAlpha = alpha;
                    }

                    data[idx] = data[idx + 1] = data[idx + 2] = Math.max(0, Math.min(255, finalGray));
                    data[idx + 3] = Math.max(0, Math.min(255, finalAlpha)); 
                }
            }
            ctx.putImageData(imgData, 0, 0);

            if (!isForSave) {
                if (currentMode === 'full' && globalPoints.length > 1) {
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const pStartLine = globalPoints[0];
                    const pEndLine = globalPoints[globalPoints.length - 1];
                    const dxLine = pEndLine.x - pStartLine.x;
                    const dyLine = pEndLine.y - pStartLine.y;
                    const lenSqLine = dxLine * dxLine + dyLine * dyLine;

                    const sortedPointsForDrawing = globalPoints.map(p => {
                        const pt = ((p.x - pStartLine.x) * dxLine + (p.y - pStartLine.y) * dyLine) / lenSqLine;
                        return { ...p, t: pt };
                    }).sort((a, b) => a.t - b.t);

                    ctx.moveTo(sortedPointsForDrawing[0].x, sortedPointsForDrawing[0].y);
                    for (let i = 1; i < sortedPointsForDrawing.length; i++) {
                        ctx.lineTo(sortedPointsForDrawing[i].x, sortedPointsForDrawing[i].y);
                    }
                    ctx.stroke();
                }

                rectangles.forEach(rectObj => {
                    ctx.strokeStyle = (rectObj.id === selectedRectId) ? "rgba(255, 255, 0, 0.5)" : "rgba(0, 255, 0, 0.1)";
                    ctx.lineWidth = 2;
                    const rectX = Math.min(rectObj.rectStart.x, rectObj.rectEnd.x);
                    const rectY = Math.min(rectObj.rectStart.y, rectObj.rectEnd.y);
                    const rectW = Math.abs(rectObj.rectEnd.x - rectObj.rectStart.x);
                    const rectH = Math.abs(rectObj.rectEnd.y - rectObj.rectStart.y);
                    ctx.strokeRect(rectX, rectY, rectW, rectH);
                });

                let pointsToDraw = [];
                if (currentMode === 'full') {
                    pointsToDraw = globalPoints;
                    pointsToDraw.forEach(p => drawPoint(p, (draggingPoint && draggingPoint.id === p.id)));
                } else if (currentMode === 'rect' && selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    if (selectedRect) {
                        pointsToDraw = selectedRect.linearGradientPoints;
                        if (pointsToDraw.length > 1) {
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            const sortedPointsForDrawing = pointsToDraw.slice().sort((a, b) => a.x - b.x);
                            ctx.moveTo(sortedPointsForDrawing[0].x, sortedPointsForDrawing[0].y);
                            for (let i = 1; i < sortedPointsForDrawing.length; i++) {
                                ctx.lineTo(sortedPointsForDrawing[i].x, sortedPointsForDrawing[i].y);
                            }
                            ctx.stroke();
                        }
                        pointsToDraw.forEach(p => drawPoint(p, (draggingPoint && draggingPoint.id === p.id)));
                    }
                }
                
                if (drawingRect && currentRect) {
                    ctx.strokeStyle = "rgba(255, 255, 0, 0.7)";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                }
            }
        }

        function drawPoint(p, isDragging) {
            ctx.fillStyle = `rgba(${p.gray}, ${p.gray}, ${p.gray}, ${p.alpha / 255})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "red";
            ctx.lineWidth = isDragging ? 3 : 1;
            ctx.stroke();
        }

        function updateControls() {
            controlsDiv.innerHTML = '';
            if (currentMode === 'full' && selectedPoint) {
                const labelText = `點 ${selectedPoint.id}`;
                createPointControl(selectedPoint, labelText);
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                const selectedRect = rectangles.find(r => r.id === selectedRectId);
                if (selectedRect) {
                    createRectControls(selectedRect);
                    if (selectedPoint) {
                       createPointControl(selectedPoint, `矩形 ${selectedRectId} 點 ${selectedPoint.id}`);
                    }
                }
            }
        }

        function createPointControl(p, labelText) {
            const wrapper = document.createElement("div");
            wrapper.className = "point-control";
            wrapper.dataset.pointId = p.id;

            const label = document.createElement("span");
            label.className = "point-label";
            label.textContent = `${labelText} (${Math.floor(p.x)},${Math.floor(p.y)})`;
            wrapper.appendChild(label);

            const grayRow = document.createElement("div");
            grayRow.className = "point-control-row";
            const grayLabel = document.createElement("span");
            grayLabel.textContent = "灰度:";
            const graySlider = document.createElement("input");
            graySlider.type = "range";
            graySlider.min = 0;
            graySlider.max = 255;
            graySlider.value = p.gray;
            graySlider.title = "灰度";
            graySlider.oninput = () => {
                p.gray = parseInt(graySlider.value);
                drawField();
            };
            grayRow.appendChild(grayLabel);
            grayRow.appendChild(graySlider);
            wrapper.appendChild(grayRow);
            
            const alphaRow = document.createElement("div");
            alphaRow.className = "point-control-row";
            const alphaLabel = document.createElement("span");
            alphaLabel.textContent = "透明度:";
            const alphaSlider = document.createElement("input");
            alphaSlider.type = "range";
            alphaSlider.min = 0;
            alphaSlider.max = 255;
            alphaSlider.value = p.alpha;
            alphaSlider.title = "透明度";
            alphaSlider.oninput = () => {
                p.alpha = parseInt(alphaSlider.value);
                drawField();
            };
            alphaRow.appendChild(alphaLabel);
            alphaRow.appendChild(alphaSlider);
            wrapper.appendChild(alphaRow);
            
            controlsDiv.appendChild(wrapper);
        }

        function createRectControls(rect) {
            const wrapper = document.createElement("div");
            wrapper.className = "rect-control-group";
            
            const title = document.createElement("h4");
            title.textContent = `矩形 ${rect.id} 屬性`;
            wrapper.appendChild(title);

            const smoothnessControl = document.createElement("div");
            smoothnessControl.className = "point-control-row";
            const smoothnessLabel = document.createElement("span");
            smoothnessLabel.className = "point-label";
            smoothnessLabel.textContent = "混合平滑度:";
            const smoothnessSlider = document.createElement("input");
            smoothnessSlider.type = "range";
            smoothnessSlider.min = 0;
            smoothnessSlider.max = 100;
            smoothnessSlider.value = rect.blendSmoothness;
            smoothnessSlider.oninput = () => {
                rect.blendSmoothness = parseInt(smoothnessSlider.value);
                drawField();
            };
            smoothnessControl.appendChild(smoothnessLabel);
            smoothnessControl.appendChild(smoothnessSlider);
            wrapper.appendChild(smoothnessControl);
            
            controlsDiv.appendChild(wrapper);

            const pointsTitle = document.createElement("h4");
            pointsTitle.textContent = "矩形內點屬性";
            controlsDiv.appendChild(pointsTitle);
        }

        function setMode(mode) {
            currentMode = mode;
            fullCanvasModeBtn.classList.toggle('active', mode === 'full');
            rectModeBtn.classList.toggle('active', mode === 'rect');

            drawingRect = false;
            rectStart = null;
            currentRect = null;
            selectedPoint = null; 
            selectedRectId = null;
            
            if (mode === 'full') {
                resetRectBtn.style.display = 'none';
                document.querySelector('h3').textContent = '全畫布模式 (線性漸變)：左右兩點固定，僅可上下移動。左鍵點擊新增點，右鍵刪除中途點。';
            } else {
                resetRectBtn.style.display = 'inline-block';
                document.querySelector('h3').textContent = '矩形模式：拖曳以定義一個新矩形。點擊已建立的矩形以進入編輯模式，然後點擊矩形內以新增或選取點，右鍵刪除非固定點。';
            }
            updateControls();
            drawField(); 
        }

        saveBtn.addEventListener("click", () => {
            drawField(true);
            const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
            saveBtn.setAttribute("href", image);
            saveBtn.setAttribute("download", "grayscale_gradient.png");
            drawField();
        });

        resetRectBtn.addEventListener("click", () => {
            rectangles = [];
            drawingRect = false;
            rectStart = null;
            currentRect = null;
            selectedPoint = null;
            selectedRectId = null;
            updateControls();
            drawField();
        });

        fullCanvasModeBtn.addEventListener("click", () => {
            initializeGlobalPoints();
            setMode('full');
        });

        rectModeBtn.addEventListener("click", () => setMode('rect'));
        
        let didDrag = false;

        canvas.addEventListener("mousedown", e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            didDrag = false;
            
            if (currentMode === 'full') {
                let foundPoint = null;
                for (let i = 0; i < globalPoints.length; i++) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }

                if (e.button === 0) {
                    if (foundPoint) {
                        draggingPoint = foundPoint;
                        selectedPoint = foundPoint;
                        canvas.style.cursor = "move";
                    } else {
                        const newPoint = { x: mouseX, y: mouseY, gray: Math.floor(Math.random() * 256), alpha: 255, id: pointIdCounter++ };
                        globalPoints.push(newPoint);
                        selectedPoint = newPoint;
                    }
                }
                
                updateControls();
                drawField();
                return;
            }

            if (e.button === 0) {
                let foundRectToSelect = null;
                for (let i = rectangles.length - 1; i >= 0; i--) {
                    const rectObj = rectangles[i];
                    const minX = Math.min(rectObj.rectStart.x, rectObj.rectEnd.x);
                    const maxX = Math.max(rectObj.rectStart.x, rectObj.rectEnd.x);
                    const minY = Math.min(rectObj.rectStart.y, rectObj.rectEnd.y);
                    const maxY = Math.max(rectObj.rectStart.y, rectObj.rectEnd.y);

                    if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
                        foundRectToSelect = rectObj;
                        break;
                    }
                }
                
                if (foundRectToSelect) {
                    selectedRectId = foundRectToSelect.id;
                    const rectPoints = foundRectToSelect.linearGradientPoints;
                    
                    let foundPointToDrag = null;
                    for (let i = 0; i < rectPoints.length; i++) {
                        const p = rectPoints[i];
                        const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                        if (dist < 10) {
                            foundPointToDrag = p;
                            break;
                        }
                    }

                    if (foundPointToDrag) {
                        draggingPoint = foundPointToDrag;
                        selectedPoint = foundPointToDrag;
                        canvas.style.cursor = "move";
                    } else {
                        const newPoint = { x: mouseX, y: rectPoints[0].y, gray: Math.floor(Math.random() * 256), alpha: 255, id: pointIdCounter++ };
                        rectPoints.push(newPoint);
                        selectedPoint = newPoint;
                    }
                    updateControls();
                    drawField();
                } else {
                    selectedRectId = null;
                    selectedPoint = null;
                    updateControls();
                    if (!drawingRect) {
                        rectStart = { x: mouseX, y: mouseY };
                        drawingRect = true;
                    }
                }
            }
        });

        canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (draggingPoint) {
                didDrag = true;
                if (currentMode === 'full') {
                    if (draggingPoint.id === 0) {
                        draggingPoint.y = mouseY; 
                        draggingPoint.x = 0; 
                    } else if (draggingPoint.id === 1) {
                        draggingPoint.y = mouseY; 
                        draggingPoint.x = w; 
                    } else {
                        draggingPoint.x = mouseX;
                        draggingPoint.y = mouseY;
                    }
                } else if (currentMode === 'rect' && selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    const rectPoints = selectedRect.linearGradientPoints;
                    const isFixedPoint = rectPoints.findIndex(p => p.id === draggingPoint.id) <= 1;
                    
                    if (!isFixedPoint) {
                        const minX = Math.min(selectedRect.rectStart.x, selectedRect.rectEnd.x);
                        const maxX = Math.max(selectedRect.rectStart.x, selectedRect.rectEnd.x);
                        draggingPoint.x = Math.max(minX, Math.min(mouseX, maxX));
                    }
                } 
                updateControls();
                drawField();
            } else if (currentMode === 'rect' && drawingRect && rectStart) {
                didDrag = true;
                currentRect = {
                    x: Math.min(rectStart.x, mouseX),
                    y: Math.min(rectStart.y, mouseY),
                    width: Math.abs(mouseX - rectStart.x),
                    height: Math.abs(mouseY - rectStart.y)
                };
                drawField();
            }
        });

        canvas.addEventListener("mouseup", e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentMode === 'rect' && drawingRect) {
                const newRectObj = {
                    id: rectIdCounter++,
                    rectStart,
                    rectEnd: { x: mouseX, y: mouseY },
                    linearGradientPoints: [],
                    blendSmoothness: 50
                };

                const newWidth = Math.abs(newRectObj.rectEnd.x - newRectObj.rectStart.x);
                const newHeight = Math.abs(newRectObj.rectEnd.y - newRectObj.rectStart.y);

                if (newWidth < 10 || newHeight < 10) {
                    alert("繪製的矩形太小，請重試。");
                    rectStart = null;
                    currentRect = null;
                } else {
                    const rectMinX = Math.min(newRectObj.rectStart.x, newRectObj.rectEnd.x);
                    const rectMaxX = Math.max(newRectObj.rectStart.x, newRectObj.rectEnd.x);
                    const rectMidY = (newRectObj.rectStart.y + newRectObj.rectEnd.y) / 2;

                    newRectObj.linearGradientPoints.push(
                        { x: rectMinX, y: rectMidY, gray: 255, alpha: 255, id: pointIdCounter++ }, 
                        { x: rectMaxX, y: rectMidY, gray: 0, alpha: 255, id: pointIdCounter++ } 
                    );
                    rectangles.push(newRectObj);
                    selectedRectId = newRectObj.id;
                }
                drawingRect = false;
                updateControls();
                drawField();
            }
            draggingPoint = null;
            canvas.style.cursor = "crosshair";
            if (didDrag) {
                e.stopImmediatePropagation();
                didDrag = false;
            }
        });

        canvas.addEventListener("click", e => {
            if (didDrag) {
                didDrag = false;
                return;
            }
            if (currentMode === 'full') {
                 let foundPoint = null;
                for (let i = 0; i < globalPoints.length; i++) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((e.offsetX - p.x) ** 2 + (e.offsetY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }
                if (foundPoint) {
                    selectedPoint = foundPoint;
                } else {
                    selectedPoint = null;
                }
                updateControls();
                drawField();
                return;
            }
            
            if (currentMode === 'rect' && selectedRectId !== null) {
                const selectedRect = rectangles.find(r => r.id === selectedRectId);
                const rectPoints = selectedRect.linearGradientPoints;
                let foundPoint = false;
                for (let i = 0; i < rectPoints.length; i++) {
                    const p = rectPoints[i];
                    const dist = Math.sqrt((e.offsetX - p.x) ** 2 + (e.offsetY - p.y) ** 2);
                    if (dist < 10) {
                        selectedPoint = p;
                        foundPoint = true;
                        break;
                    }
                }
                if (!foundPoint) {
                    selectedPoint = null;
                }
                updateControls();
                drawField();
            }
        });

        canvas.addEventListener("contextmenu", e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (currentMode === 'full') {
                for (let i = globalPoints.length - 1; i >= 0; i--) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                    if (dist < 10 && p.id > 1) {
                        globalPoints.splice(i, 1);
                        selectedPoint = null;
                        updateControls();
                        drawField();
                        return;
                    }
                }
            } else if (currentMode === 'rect') {
                if (selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    const rectPoints = selectedRect.linearGradientPoints;
                    const minX = Math.min(selectedRect.rectStart.x, selectedRect.rectEnd.x);
                    const maxX = Math.max(selectedRect.rectStart.x, selectedRect.rectEnd.x);
                    const minY = Math.min(selectedRect.rectStart.y, selectedRect.rectEnd.y);
                    const maxY = Math.max(selectedRect.rectStart.y, selectedRect.rectEnd.y);

                    if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
                        for (let i = rectPoints.length - 1; i >= 0; i--) {
                            const p = rectPoints[i];
                            const dist = Math.sqrt((mouseX - p.x)**2 + (mouseY - p.y)**2);
                            
                            // 修正：檢查是否為固定點
                            const isFixedPoint = (p.x === minX || p.x === maxX) && (p.y === (minY + maxY) / 2);
                            
                            if (dist < 10 && !isFixedPoint) {
                                rectPoints.splice(i, 1);
                                selectedPoint = null;
                                updateControls();
                                drawField();
                                return;
                            }
                        }
                    }
                }
                
                for (let i = rectangles.length - 1; i >= 0; i--) {
                    const rectObj = rectangles[i];
                    const minX = Math.min(rectObj.rectStart.x, rectObj.rectEnd.x);
                    const maxX = Math.max(rectObj.rectStart.x, rectObj.rectEnd.x);
                    const minY = Math.min(rectObj.rectStart.y, rectObj.rectEnd.y);
                    const maxY = Math.max(rectObj.rectStart.y, rectObj.rectEnd.y);
                    
                    if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
                        rectangles.splice(i, 1);
                        selectedRectId = null;
                        updateControls();
                        drawField();
                        return;
                    }
                }
            }
        });
        
        initializeGlobalPoints();
        setMode('full');
    </script>
</body>
</html>