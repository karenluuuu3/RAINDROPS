<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <title>RAINDROPS</title>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: sans-serif;
            padding: 20px;
        }

        /* New style for the main layout container */
        .main-layout {
            display: flex;
            align-items: flex-start;
            gap: 20px; /* Space between canvas and controls */
        }

        .canvas-container {
            width: 1280px;
            height: 720px;
            overflow-x: auto;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        .mode-buttons {
            margin-top: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 8px 15px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mode-button.active {
            background-color: #007bff;
        }
        
        .mode-button:hover:not(.active) {
            background-color: #555;
        }

        .controls-container {
            /* margin-top: 20px;  <-- This is no longer needed */
            margin-top: 0; 
            display: flex;
            gap: 20px;
        }

        .controls {
            width: 400px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .point-control {
            margin: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .point-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .point-label {
            min-width: 60px;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
        }

        .main-actions {
            margin-top: 15px;
            text-align: center;
        }

        .main-actions button, .main-actions a {
            padding: 10px 20px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            text-decoration: none;
            display: inline-block;
            transition: background-color 0.2s;
        }

        .main-actions button:hover, .main-actions a:hover {
            background-color: #666;
        }

        .canvas-size-controls {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>

<body>
    <div class="mode-buttons">
        <button id="full-canvas-mode-btn" class="mode-button active">全畫布</button>
        <button id="rect-mode-btn" class="mode-button">矩形模式</button>
    </div>

    <div class="canvas-size-controls">
        <label for="viewWidthInput">工作區寬度:</label>
        <input type="number" id="viewWidthInput" value="1280" min="100">
        <label for="longWidthInput">卷軸長度:</label>
        <input type="number" id="longWidthInput" value="1280" min="100">
        <label for="heightInput">卷軸高度:</label>
        <input type="number" id="heightInput" value="720" min="100">
        <button id="update-canvas-btn">更新畫布</button>
    </div>

    <div class="main-layout">
        
        <div>
            <div style="display: flex; align-items: flex-start;">
                <div id="left-labels" style="width: 40px; text-align: right; color: white;"></div>
                <div class="canvas-container" id="canvas-container">
                    <canvas id="canvas" width="1280" height="720"></canvas>
                </div>
                <div id="right-labels" style="width: 40px; color: white;"></div>
            </div>
            <div class="main-actions">
                <a id="save-btn" href="#">儲存圖片</a>
            </div>
        </div>

        <div class="controls-container">
            <div class="controls" id="points-controls">
                <h4>控制點屬性</h4>
                <div id="controls"></div>
            </div>
        </div>
    </div>


    <script>
    (() => {
        // ---- Constants ----
        const RECT_COUNT = 50;
        const MAX_HISTORY = 50;
        const POINT_RADIUS = 5;
        const HIT_RADIUS = 10;

        // ---- DOM Elements ----
        const canvasContainer = document.getElementById("canvas-container");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const viewWidthInput = document.getElementById("viewWidthInput");
        const longWidthInput = document.getElementById("longWidthInput");
        const heightInput = document.getElementById("heightInput");
        const updateCanvasBtn = document.getElementById("update-canvas-btn");
        const controlsDiv = document.getElementById("controls");
        const saveBtn = document.getElementById("save-btn");
        const fullCanvasModeBtn = document.getElementById("full-canvas-mode-btn");
        const rectModeBtn = document.getElementById("rect-mode-btn");
        const leftLabels = document.getElementById('left-labels');
        const rightLabels = document.getElementById('right-labels');

        // ---- State ----
        let w = canvas.width;
        let h = canvas.height;
        let globalPoints = [];
        let rectangles = [];
        let pointIdCounter = 0;
        let currentMode = 'full';
        
        let draggingPoint = null;
        let selectedPoint = null;
        let selectedRectId = null;
        
        let history = [];
        let historyIndex = -1;
        
        let didDrag = false;
        let needsRedraw = true;
        let isDraggingCanvas = false;
        let lastDragX = 0;

        // ---- State Management ----
        function saveState() {
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            const state = {
                globalPoints: JSON.parse(JSON.stringify(globalPoints)),
                rectangles: JSON.parse(JSON.stringify(rectangles))
            };
            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            historyIndex = history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const prevState = JSON.parse(JSON.stringify(history[historyIndex]));
                globalPoints = prevState.globalPoints;
                rectangles = prevState.rectangles;
                
                selectedPoint = null;
                requestDraw();
                updateControls();
            }
        }

        // ---- Initialization ----
        function initialize() {
            initializeGlobalPoints();
            initializeRectangles();
            createSideLabels();
            setupEventListeners();
            setMode('full', false);
            saveState();
            draw();
        }

        function initializeGlobalPoints() {
            pointIdCounter = 0;
            globalPoints = [
                { x: 0, y: h / 2, gray: 0, alpha: 0, id: pointIdCounter++ },
                { x: w, y: h / 2, gray: 0, alpha: 0, id: pointIdCounter++ }
            ];
            if (globalPoints.length > 0) {
                selectedPoint = globalPoints[0];
            }
        }

        function initializeRectangles() {
            rectangles = [];
            const rectHeight = h / RECT_COUNT;
            for (let i = 0; i < RECT_COUNT; i++) {
                const rectY = i * rectHeight;
                const rectMidY = rectY + rectHeight / 2;
                rectangles.push({
                    id: i,
                    y: rectY,
                    height: rectHeight,
                    points: [
                        { x: 0, y: rectMidY, gray: 0, alpha: 0, id: pointIdCounter++ },
                        { x: w, y: rectMidY, gray: 0, alpha: 0, id: pointIdCounter++ }
                    ]
                });
            }
        }

        // ---- Drawing Engine (Optimized) ----
        function requestDraw() {
            if (!needsRedraw) {
                needsRedraw = true;
                requestAnimationFrame(draw);
            }
        }
        
        function draw() {
            if (!needsRedraw) return;

            ctx.clearRect(0, 0, w, h);
            
            // 1. Draw background gradient
            drawNativeGradient(globalPoints, { x: 0, y: 0, w, h });

            // 2. Draw rectangle gradients on top
            rectangles.forEach(rect => {
                const hasEffect = rect.points.some(p => p.alpha > 0);
                if (rect.points.length > 2 || hasEffect) {
                     drawNativeGradient(rect.points, { x: 0, y: rect.y, w, h: rect.height });
                }
            });

            // 3. Draw UI elements (points, lines, selections)
            if (typeof window.drawUI === 'function') {
                window.drawUI();
            }
            
            needsRedraw = false;
        }

        function drawNativeGradient(points, bounds) {
            if (points.length < 2) return;

            const sortedByX = [...points].sort((a, b) => a.x - b.x);
            const pStart = sortedByX[0];
            const pEnd = sortedByX[sortedByX.length - 1];

            const dx = pEnd.x - pStart.x;
            const dy = pEnd.y - pStart.y;
            const lenSq = dx * dx + dy * dy;

            if (lenSq === 0) return;

            const gradient = ctx.createLinearGradient(pStart.x, pStart.y, pEnd.x, pEnd.y);
            
            const projectedPoints = points.map(p => {
                const t = ((p.x - pStart.x) * dx + (p.y - pStart.y) * dy) / lenSq;
                return { ...p, t: Math.max(0, Math.min(1, t)) };
            }).sort((a, b) => a.t - b.t);

            projectedPoints.forEach(p => {
                gradient.addColorStop(p.t, `rgba(${p.gray}, ${p.gray}, ${p.gray}, ${p.alpha / 255})`);
            });
            
            ctx.fillStyle = gradient;
            ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
        }
        
        window.drawUI = function() {
            const pointsToDraw = (currentMode === 'full') 
                ? globalPoints 
                : (selectedRectId !== null ? rectangles[selectedRectId]?.points : []);

            // Draw connector line (no changes here)
            if (pointsToDraw.length > 1) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                const sorted = [...pointsToDraw].sort((a, b) => a.x - b.x);
                ctx.moveTo(sorted[0].x, sorted[0].y);
                for (let i = 1; i < sorted.length; i++) {
                    ctx.lineTo(sorted[i].x, sorted[i].y);
                }
                ctx.stroke();
            }

            // Draw points
            pointsToDraw.forEach(p => {
                const isSelected = selectedPoint && selectedPoint.id === p.id;

                if (currentMode === 'rect' && selectedRectId !== null) {
                    const rect = rectangles[selectedRectId];
                    if (rect) {
                        // Draw the vertical line through the rectangle
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p.x, rect.y - 10);
                        ctx.lineTo(p.x, rect.y + rect.height + 10 );
                        ctx.stroke();
                    }
                }

                // Draw the circle itself
                ctx.fillStyle = `rgb(${p.gray}, ${p.gray}, ${p.gray})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                // Draw the circle's border (white, or red if selected)
                ctx.strokeStyle = isSelected ? "red" : "#FFF";
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.stroke();
            });
        }

        // ---- UI Updates ----
        function updateControls() {
            const pointsToUse = (currentMode === 'full') 
                ? globalPoints 
                : (selectedRectId !== null ? rectangles[selectedRectId]?.points : null);

            if (!selectedPoint || !pointsToUse || !pointsToUse.find(p => p.id === selectedPoint.id)) {
                controlsDiv.innerHTML = '';
                return;
            }

            const p = selectedPoint;
            const controlWrapper = document.createElement("div");
            controlWrapper.className = "point-control";

            const labelText = (currentMode === 'rect' && selectedRectId !== null)
                ? `區域 ${selectedRectId + 1} 點 ${p.id}`
                : `點 ${p.id}`;

            controlWrapper.innerHTML = `
                <span class="point-label">${labelText} (${p.x.toFixed(0)},${p.y.toFixed(0)})</span>
                <div class="point-control-row">
                    <span>灰度:</span>
                    <input type="range" min="0" max="255" value="${p.gray}" data-prop="gray">
                </div>
                <div class="point-control-row">
                    <span>透明度:</span>
                    <input type="range" min="0" max="255" value="${p.alpha}" data-prop="alpha">
                </div>
            `;

            controlWrapper.querySelectorAll('input[type="range"]').forEach(slider => {
                slider.oninput = () => {
                    p[slider.dataset.prop] = parseInt(slider.value);
                    requestDraw();
                };
                slider.onchange = () => saveState();
            });

            controlsDiv.replaceChildren(controlWrapper);
        }

        function setMode(mode, doSaveState = true) {
            currentMode = mode;
            fullCanvasModeBtn.classList.toggle('active', mode === 'full');
            rectModeBtn.classList.toggle('active', mode === 'rect');
            
            selectedPoint = null;
            selectedRectId = null;

            if (doSaveState) saveState();
            
            updateControls();
            requestDraw();
        }

        function createSideLabels() {
            const rectHeight = h / RECT_COUNT;
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < RECT_COUNT; i++) {
                const label = document.createElement('div');
                label.style.height = `${rectHeight}px`;
                label.style.lineHeight = `${rectHeight}px`;
                label.style.fontSize = '12px';
                label.textContent = i + 1;
                fragment.appendChild(label);
            }
            leftLabels.replaceChildren(fragment.cloneNode(true));
            rightLabels.replaceChildren(fragment);
        }

        // ---- Event Handlers ----
        function setupEventListeners() {
            canvas.addEventListener("mousedown", handleMouseDown);
            canvas.addEventListener("mousemove", handleMouseMove);
            window.addEventListener("mouseup", handleMouseUp);
            canvas.addEventListener("contextmenu", handleContextMenu);
            canvas.addEventListener("click", handleClick);

            canvasContainer.addEventListener('mousedown', handleContainerDragStart);
            canvasContainer.addEventListener('mousemove', handleContainerDrag);
            window.addEventListener('mouseup', handleContainerDragEnd);
            canvasContainer.addEventListener('mouseleave', handleContainerDragEnd);
            
            fullCanvasModeBtn.addEventListener("click", () => setMode('full'));
            rectModeBtn.addEventListener("click", () => setMode('rect'));
            updateCanvasBtn.addEventListener("click", handleUpdateCanvas);
            saveBtn.addEventListener("click", handleSaveImage);
            
            window.addEventListener('keydown', e => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                }
            });
        }

        function handleMouseDown(e) {
            if (e.button !== 0) return;
            const { x, y } = getMouseCoords(e);
            didDrag = false;

            const pointToDrag = getPointAtCoords(x, y);
            if (pointToDrag) {
                draggingPoint = pointToDrag;
                selectedPoint = pointToDrag;
                canvas.style.cursor = "move";
            } else {
                // Read the color of the pixel at the click location to use as the new point's default color.
                const pixelData = ctx.getImageData(x, y, 1, 1).data;
                const newGrayValue = pixelData[0]; // For grayscale, R, G, and B are the same.

                if (currentMode === 'full') {
                    // Use the read color instead of a hardcoded gray value.
                    const newPoint = { x, y, gray: 0, alpha: 0, id: pointIdCounter++ };
                    globalPoints.push(newPoint);
                    selectedPoint = newPoint;
                    draggingPoint = newPoint;
                    saveState();
                } else if (currentMode === 'rect') {
                    const rectIndex = Math.floor(y / (h / RECT_COUNT));
                    if (rectangles[rectIndex]) {
                        selectedRectId = rectIndex;
                        const rectMidY = rectangles[rectIndex].y + rectangles[rectIndex].height / 2;
                        // Use the read color instead of a hardcoded gray value.
                        const newPoint = { x, y: rectMidY, gray: 0, alpha: 0, id: pointIdCounter++ };
                        rectangles[rectIndex].points.push(newPoint);
                        selectedPoint = newPoint;
                        draggingPoint = newPoint;
                        saveState();
                    }
                }
            }
            updateControls();
            requestDraw();
        }

        function handleMouseMove(e) {
            if (!draggingPoint) return;
            didDrag = true;
            const { x, y } = getMouseCoords(e);

            if (currentMode === 'full') {
                const isEndPoint = draggingPoint.id === 0 || draggingPoint.id === 1;
                draggingPoint.x = isEndPoint ? draggingPoint.x : Math.max(0, Math.min(w, x));
                draggingPoint.y = Math.max(0, Math.min(h, y));
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                const rect = rectangles[selectedRectId];
                const isFixedPoint = rect.points.findIndex(p => p.id === draggingPoint.id) < 2;
                if (!isFixedPoint) {
                    draggingPoint.x = Math.max(0, Math.min(w, x));
                }
            }
            updateControls();
            requestDraw();
        }

        function handleMouseUp() {
            if (draggingPoint && didDrag) {
                saveState();
            }
            draggingPoint = null;
            canvas.style.cursor = "crosshair";
        }
        
        function handleClick(e) {
            if (didDrag) return;
            const { x, y } = getMouseCoords(e);
            
            if (currentMode === 'rect') {
                const rectIndex = Math.floor(y / (h / RECT_COUNT));
                selectedRectId = (rectangles[rectIndex]) ? rectIndex : null;
            }
            
            selectedPoint = getPointAtCoords(x, y);
            
            // --- MODIFICATION START ---
            // If we clicked on an inactive placeholder point in rect mode, activate it.
            if (currentMode === 'rect' && selectedPoint && selectedPoint.alpha === 0) {
                // Temporarily disable UI drawing to sample the pure gradient color
                const originalDrawUI = window.drawUI;
                window.drawUI = () => {};
                needsRedraw = true;
                draw();

                // Sample the color at the point's location
                const pixelData = ctx.getImageData(selectedPoint.x, selectedPoint.y, 1, 1).data;
                const sampledGray = pixelData[0];

                // Restore the UI drawing function
                window.drawUI = originalDrawUI;

                // Update the point's properties to make it active
                selectedPoint.gray = 0;
                selectedPoint.alpha = 0;
                
                // Save this change to history
                saveState();
            }
            // --- MODIFICATION END ---

            updateControls();
            requestDraw();
        }
        
        function handleContextMenu(e) {
            e.preventDefault();
            const { x, y } = getMouseCoords(e);
            const pointToDelete = getPointAtCoords(x, y);

            if (!pointToDelete) return;

            let pointsArray;
            if (currentMode === 'full') {
                if (pointToDelete.id === 0 || pointToDelete.id === 1) return;
                pointsArray = globalPoints;
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                pointsArray = rectangles[selectedRectId].points;
                if (pointsArray.findIndex(p => p.id === pointToDelete.id) < 2) return;
            } else {
                return;
            }

            const index = pointsArray.findIndex(p => p.id === pointToDelete.id);
            if (index > -1) {
                pointsArray.splice(index, 1);
                if (selectedPoint && selectedPoint.id === pointToDelete.id) {
                    selectedPoint = null;
                }
                saveState();
                updateControls();
                requestDraw();
            }
        }

        function handleUpdateCanvas() {
            const newViewWidth = parseInt(viewWidthInput.value) || 1280;
            const newLongWidth = parseInt(longWidthInput.value) || 1280;
            const newHeight = parseInt(heightInput.value) || 720;
            
            const oldW = w;
            const isEnlarging = newLongWidth > oldW;

            if (newLongWidth === w && newHeight === h) return;
            
            w = newLongWidth;
            h = newHeight;
            
            canvasContainer.style.width = `${newViewWidth}px`;
            canvasContainer.style.height = `${newHeight}px`;
            canvas.width = w;
            canvas.height = h;

            // Adjust global points
            const leftEndPoint = globalPoints.find(p => p.id === 0);
            if(leftEndPoint) leftEndPoint.y = h / 2;

            const rightEndPoint = globalPoints.find(p => p.id === 1);
            if(rightEndPoint) {
                if (isEnlarging) {
                    // Add a new point at the old boundary to preserve the gradient
                    const newIntermediatePoint = {
                        x: oldW,
                        y: rightEndPoint.y,
                        gray: rightEndPoint.gray,
                        alpha: rightEndPoint.alpha,
                        id: pointIdCounter++
                    };
                    globalPoints.push(newIntermediatePoint);
                }
                rightEndPoint.x = w;
                rightEndPoint.y = h / 2;
            }

            // Adjust points in each rectangle
            const newRectHeight = h / RECT_COUNT;
            rectangles.forEach((rect, i) => {
                const newY = i * newRectHeight;
                const newMidY = newY + newRectHeight / 2;
                rect.y = newY;
                rect.height = newRectHeight;
                
                const rectRightEndPoint = rect.points[1];
                if (isEnlarging && rectRightEndPoint) {
                    const newIntermediatePoint = {
                        x: oldW,
                        y: newMidY,
                        gray: rectRightEndPoint.gray,
                        alpha: rectRightEndPoint.alpha,
                        id: pointIdCounter++
                    };
                    rect.points.push(newIntermediatePoint);
                }

                rect.points.forEach((p, index) => {
                    if (index === 0) p.x = 0;
                    if (index === 1) p.x = w;
                    p.y = newMidY;
                });
            });
            
            createSideLabels();
            saveState();
            requestDraw();
        }

        function handleSaveImage(e) {
            e.preventDefault();
            const originalDrawUI = window.drawUI;
            window.drawUI = () => {}; // Temporarily disable UI drawing
            needsRedraw = true;
            draw();
            
            const image = canvas.toDataURL("image/png");
            
            window.drawUI = originalDrawUI; // Restore UI drawing
            requestDraw();
            
            // Use a temporary link to trigger download
            const link = document.createElement('a');
            link.href = image;
            link.download = "gradient.png";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function handleContainerDragStart(e) {
            if (e.button === 1) { // Middle mouse button
                isDraggingCanvas = true;
                lastDragX = e.clientX;
                canvasContainer.style.cursor = 'grabbing';
                e.preventDefault();
            }
        }
        function handleContainerDrag(e) {
            if (!isDraggingCanvas) return;
            const dx = e.clientX - lastDragX;
            canvasContainer.scrollLeft -= dx;
            lastDragX = e.clientX;
        }
        function handleContainerDragEnd() {
            isDraggingCanvas = false;
            canvasContainer.style.cursor = 'crosshair';
        }

        // ---- Helpers ----
        function getMouseCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
            };
        }

        function getPointAtCoords(x, y) {
            let pointsToSearch = [];
            if (currentMode === 'full') {
                pointsToSearch = globalPoints;
            } else if (currentMode === 'rect') {
                const rectIndex = Math.floor(y / (h / RECT_COUNT));
                if (rectangles[rectIndex]) {
                    selectedRectId = rectIndex;
                    pointsToSearch = rectangles[rectIndex].points;
                }
            }
            
            if (!pointsToSearch.length) return null;

            let closestPoint = null;
            let minDistance = HIT_RADIUS;

            for (const p of pointsToSearch) {
                const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestPoint = p;
                }
            }
            return closestPoint;
        }

        // ---- App Entry Point ----
        initialize();
    })();
</script>
</body>

</html>