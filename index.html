<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <title>RAINDROPS</title>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: sans-serif;
            padding: 20px;
        }

        .canvas-container {
            width: 1280px;
            /* 畫布的顯示寬度 */
            height: 720px;
            overflow-x: auto;
            /* 啟用水平捲軸 */
            border: 2px solid #555;
            border-radius: 8px;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        .mode-buttons {
            margin-top: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 8px 15px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .mode-button.active {
            background-color: #007bff;
        }

        .controls-container {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }

        .controls {
            width: 400px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .point-control {
            margin: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .point-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .point-label {
            min-width: 60px;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
        }

        #save-btn,
        #reset-rect-btn,
        #update-canvas-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }

        #save-btn:hover,
        #reset-rect-btn:hover,
        #update-canvas-btn:hover {
            background-color: #666;
        }

        .canvas-size-controls {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>

<body>
    <h3>切換模式以進行操作</h3>
    <div class="mode-buttons">
        <button id="full-canvas-mode-btn" class="mode-button active">全畫布</button>
        <button id="rect-mode-btn" class="mode-button">矩形模式</button>
    </div>

    <div class="canvas-size-controls">
        <label for="viewWidthInput">工作區寬度:</label>
        <input type="number" id="viewWidthInput" value="1280" min="1280">
        <label for="longWidthInput">卷軸長度:</label>
        <input type="number" id="longWidthInput" value="1280" min="1280">
        <label for="heightInput">卷軸高度:</label>
        <input type="number" id="heightInput" value="720" min="720">
        <button id="update-canvas-btn">更新畫布</button>
    </div>





    <div style="display: flex; align-items: flex-start;">
        <!-- 左側編號 -->
        <div id="left-labels" style="width: 40px; text-align: right; color: white;"></div>

        <!-- Canvas 容器 -->
        <div class="canvas-container">
            <canvas id="canvas" width="1280" height="720"></canvas>
        </div>

        <!-- 右側編號 -->
        <div id="right-labels" style="width: 40px; color: white;"></div>
    </div>






    <a id="save-btn" href="#">儲存圖片</a>
    <button id="reset-rect-btn" style="display: none;">重設所有矩形</button>

    <div class="controls-container">
        <div class="controls" id="points-controls">
            <h4>控制點屬性</h4>
            <div id="controls"></div>
        </div>
    </div>


    <script>
        let canvasContainer = document.querySelector(".canvas-container");
        let canvas = document.getElementById("canvas");
        let ctx = canvas.getContext("2d");
        const viewWidthInput = document.getElementById("viewWidthInput");
        const longWidthInput = document.getElementById("longWidthInput");
        const heightInput = document.getElementById("heightInput");
        const updateCanvasBtn = document.getElementById("update-canvas-btn");
        const controlsDiv = document.getElementById("controls");
        const saveBtn = document.getElementById("save-btn");
        const fullCanvasModeBtn = document.getElementById("full-canvas-mode-btn");
        const rectModeBtn = document.getElementById("rect-mode-btn");
        const resetRectBtn = document.getElementById("reset-rect-btn");

        let w = canvas.width;
        let h = canvas.height;
        let globalPoints = [];
        let draggingPoint = null;
        let selectedPoint = null;
        let pointIdCounter = 0;

        let rectangles = [];
        let RECT_COUNT = 50;
        let selectedRectId = null;

        let currentMode = 'full';

        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        let isDrawing = false;
        let throttleTimeout = null;
        const THROTTLE_DELAY = 16; // 節流延遲，約 60fps

        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            let state;
            if (currentMode === 'full') {
                state = { mode: 'full', points: JSON.parse(JSON.stringify(globalPoints)) };
            } else {
                state = { mode: 'rect', rectangles: JSON.parse(JSON.stringify(rectangles)), selectedRectId: selectedRectId };
            }
            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            historyIndex = history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const prevState = history[historyIndex];
                if (prevState.mode === 'full') {
                    currentMode = 'full';
                    globalPoints = prevState.points;
                    selectedRectId = null;
                } else {
                    currentMode = 'rect';
                    rectangles = prevState.rectangles;
                    selectedRectId = prevState.selectedRectId;
                }
                selectedPoint = null;
                setMode(currentMode, false);
                drawField();
                updateControls();
            }
        }

        function initializeGlobalPoints() {
            pointIdCounter = 0;
            globalPoints = [
                { x: 0, y: h / 2, gray: 255, alpha: 255, id: pointIdCounter++ },
                { x: w, y: h / 2, gray: 0, alpha: 255, id: pointIdCounter++ }
            ];
            if (globalPoints.length > 0) {
                selectedPoint = globalPoints[0];
            }
        }

        function initializeRectangles() {
            rectangles = [];
            const rectHeight = h / RECT_COUNT;
            for (let i = 0; i < RECT_COUNT; i++) {
                const rectY = i * rectHeight;
                const rectMidY = rectY + rectHeight / 2;
                const newRectObj = {
                    id: i,
                    rectStart: { x: 0, y: rectY },
                    rectEnd: { x: w, y: rectY + rectHeight },
                    linearGradientPoints: [
                        { x: 0, y: rectMidY, gray: 255, alpha: 255, id: pointIdCounter++ },
                        { x: w, y: rectMidY, gray: 0, alpha: 255, id: pointIdCounter++ }
                    ]
                };
                rectangles.push(newRectObj);
            }
        }

        function calculateLinearGradientWithAlpha(points, x, y) {
            if (points.length === 0) return { gray: 0, alpha: 0 };
            if (points.length === 1) return { gray: points[0].gray, alpha: points[0].alpha };
            
            const sortedByX = points.slice().sort((a, b) => a.x - b.x);
            const pStartLine = sortedByX[0];
            const pEndLine = sortedByX[sortedByX.length - 1];

            const dxLine = pEndLine.x - pStartLine.x;
            const dyLine = pEndLine.y - pStartLine.y;
            const lenSqLine = dxLine * dxLine + dyLine * dyLine;

            let t = 0;
            if (lenSqLine > 0) {
                t = ((x - pStartLine.x) * dxLine + (y - pStartLine.y) * dyLine) / lenSqLine;
            }

            const sortedPoints = points.map(p => {
                const p_t = lenSqLine > 0 ? (((p.x - pStartLine.x) * dxLine + (p.y - pStartLine.y) * dyLine) / lenSqLine) : (p.x / w);
                return { ...p, t: p_t };
            }).sort((a, b) => a.t - b.t);

            let gray, alpha;
            if (t <= sortedPoints[0].t) {
                gray = sortedPoints[0].gray;
                alpha = sortedPoints[0].alpha;
            } else if (t >= sortedPoints[sortedPoints.length - 1].t) {
                gray = sortedPoints[sortedPoints.length - 1].gray;
                alpha = sortedPoints[sortedPoints.length - 1].alpha;
            } else {
                let pA, pB;
                for (let i = 0; i < sortedPoints.length - 1; i++) {
                    if (t >= sortedPoints[i].t && t <= sortedPoints[i + 1].t) {
                        pA = sortedPoints[i];
                        pB = sortedPoints[i + 1];

                        const segmentLength = pB.t - pA.t;
                        const localT = (segmentLength > 0) ? (t - pA.t) / segmentLength : 0;
                        gray = pA.gray * (1 - localT) + pB.gray * localT;
                        alpha = pA.alpha * (1 - localT) + pB.alpha * localT;
                        break;
                    }
                    if (i === sortedPoints.length - 2 && t > sortedPoints[i + 1].t) {
                        gray = sortedPoints[i + 1].gray;
                        alpha = sortedPoints[i + 1].alpha;
                        break;
                    }
                }
                if (typeof gray === 'undefined') {
                    gray = sortedPoints[sortedPoints.length - 1].gray;
                    alpha = sortedPoints[sortedPoints.length - 1].alpha;
                }
            }
            return { gray, alpha };
        }

        function drawField(isForSave = false) {
            let imgData = ctx.createImageData(w, h);
            let data = imgData.data;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    const { gray: bgGray, alpha: bgAlpha } = calculateLinearGradientWithAlpha(globalPoints, x, y);
                    let finalGray, finalAlpha;

                    const rectHeight = h / RECT_COUNT;
                    const rectIndex = Math.floor(y / rectHeight);
                    const currentRect = rectangles[rectIndex];

                    if (currentRect && currentRect.linearGradientPoints.length > 2) {
                        const { gray: rectGray, alpha: rectAlpha } = calculateLinearGradientWithAlpha(currentRect.linearGradientPoints, x, y);
                        const blendFactor = rectAlpha / 255;
                        finalGray = rectGray * blendFactor + bgGray * (1 - blendFactor);
                        finalAlpha = rectAlpha + bgAlpha * (1 - blendFactor);
                    } else {
                        finalGray = bgGray;
                        finalAlpha = bgAlpha;
                    }

                    data[idx] = data[idx + 1] = data[idx + 2] = Math.max(0, Math.min(255, finalGray));
                    data[idx + 3] = Math.max(0, Math.min(255, finalAlpha));
                }
            }
            ctx.putImageData(imgData, 0, 0);

            if (!isForSave) {
                let pointsToDraw = [];
                if (currentMode === 'full') { 
                    pointsToDraw = globalPoints;
                    if (pointsToDraw.length > 1) {
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const sortedByX = pointsToDraw.slice().sort((a, b) => a.x - b.x);
                        ctx.moveTo(sortedByX[0].x, sortedByX[0].y);
                        for (let i = 1; i < sortedByX.length; i++) {
                            ctx.lineTo(sortedByX[i].x, sortedByX[i].y);
                        }
                        ctx.stroke();
                    }
                    globalPoints.forEach(p => drawPoint(p, draggingPoint && draggingPoint.id === p.id));
                } else if (currentMode === 'rect') {
                    ctx.fillStyle = "white";
                    ctx.font = "12px Arial";
                    ctx.textBaseline = "middle";
                    const rectHeight = h / RECT_COUNT;// RECT_COUNT = 50

                    if (selectedRectId !== null) {
                        const selectedRect = rectangles.find(r => r.id === selectedRectId);
                        if (selectedRect) {
                            const rectX = Math.min(selectedRect.rectStart.x, selectedRect.rectEnd.x);
                            const rectY = Math.min(selectedRect.rectStart.y, selectedRect.rectEnd.y);
                            const rectW = Math.abs(selectedRect.rectEnd.x - selectedRect.rectStart.x);
                            const rectH = Math.abs(selectedRect.rectEnd.y - selectedRect.rectStart.y);

                            ctx.strokeStyle = "rgba(255, 255, 0, 0.0)";
                            ctx.lineWidth = 2;
                            ctx.strokeRect(rectX, rectY, rectW, rectH);
                            pointsToDraw = selectedRect.linearGradientPoints;
                            pointsToDraw.forEach(p => drawPoint(p, (draggingPoint && draggingPoint.id === p.id)));
                        }
                    }
                }
            }
        }

        function drawPoint(p, isDragging) {
            ctx.fillStyle = `rgba(${p.gray}, ${p.gray}, ${p.gray}, ${p.alpha / 255})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = "red";
            if (isDragging || (selectedPoint && selectedPoint.id === p.id)) {
                ctx.lineWidth = 3;
            } else {
                ctx.lineWidth = 1;
            }
            ctx.stroke();
        }

        function updateControls() {
            controlsDiv.innerHTML = '';
            let pointsToUse = null;
            if (currentMode === 'full') {
                pointsToUse = globalPoints;
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                const selectedRect = rectangles.find(r => r.id === selectedRectId);
                if (selectedRect) {
                    pointsToUse = selectedRect.linearGradientPoints;
                }
            }

            if (selectedPoint && pointsToUse && pointsToUse.includes(selectedPoint)) {
                let labelText = `點 ${selectedPoint.id}`;
                
                if (currentMode === 'rect') {
                    labelText = `區域 ${selectedRectId + 1} 點 ${selectedPoint.id}`;
                }
                createPointControl(selectedPoint, labelText);
            }
        }


        function createPointControl(p, labelText) {
            const wrapper = document.createElement("div");
            wrapper.className = "point-control";
            wrapper.dataset.pointId = p.id;

            const label = document.createElement("span");
            label.className = "point-label";
            label.textContent = `${labelText} (${Math.floor(p.x)},${Math.floor(p.y)})`; 
            wrapper.appendChild(label);

            const grayRow = document.createElement("div");
            grayRow.className = "point-control-row";
            const grayLabel = document.createElement("span");
            grayLabel.textContent = "灰度:";
            const graySlider = document.createElement("input");
            graySlider.type = "range";
            graySlider.min = 0;
            graySlider.max = 255;
            graySlider.value = p.gray;
            graySlider.title = "灰度";
            graySlider.oninput = () => {
                p.gray = parseInt(graySlider.value);
                throttleDraw();
            };
            grayRow.appendChild(grayLabel);
            grayRow.appendChild(graySlider);
            wrapper.appendChild(grayRow);

            const alphaRow = document.createElement("div");
            alphaRow.className = "point-control-row";
            const alphaLabel = document.createElement("span");
            alphaLabel.textContent = "透明度:";
            const alphaSlider = document.createElement("input");
            alphaSlider.type = "range";
            alphaSlider.min = 0;
            alphaSlider.max = 255;
            alphaSlider.value = p.alpha;
            alphaSlider.title = "透明度";
            alphaSlider.oninput = () => {
                p.alpha = parseInt(alphaSlider.value);
                throttleDraw();
            };
            alphaRow.appendChild(alphaLabel);
            alphaRow.appendChild(alphaSlider);
            wrapper.appendChild(alphaRow);

            controlsDiv.appendChild(wrapper);
        }

        function setMode(mode, save = true) {
            currentMode = mode;
            fullCanvasModeBtn.classList.toggle('active', mode === 'full');
            rectModeBtn.classList.toggle('active', mode === 'rect');
            selectedPoint = null;
            if (mode === 'full') {
                selectedRectId = null;
                resetRectBtn.style.display = 'none';
                document.querySelector('h3').textContent = '全畫布模式 (線性漸變)：左右兩點固定，僅可上下移動。左鍵點擊新增點，右鍵刪除中途點。';
            } else {
                if (selectedRectId !== null && !rectangles[selectedRectId]) {
                    selectedRectId = null;
                }
                resetRectBtn.style.display = 'none';
                document.querySelector('h3').textContent = '矩形模式：點擊一個區域以選取它，然後點擊區域內以新增或選取點，右鍵刪除非固定點。';
            }
            updateControls();
            drawField();
            if (save) {
                saveState();
            }
        }


        function createSideLabels() {
            const leftDiv = document.getElementById('left-labels');
            const rightDiv = document.getElementById('right-labels');
            leftDiv.innerHTML = '';
            rightDiv.innerHTML = '';

            const rectHeight = h / RECT_COUNT;

            for (let i = 0; i < RECT_COUNT; i++) {
                const label = document.createElement('div');
                label.style.height = rectHeight + 'px';
                label.style.lineHeight = rectHeight + 'px';
                label.style.fontSize = '14px';
                label.textContent = i + 1;
                leftDiv.appendChild(label);

                const rightLabel = label.cloneNode(true);
                rightDiv.appendChild(rightLabel);
            }
        }

        

        let isDraggingCanvas = false;
        let lastX = 0;
        let lastScrollLeft = 0;

        canvasContainer.addEventListener('mousedown', e => {
            if (e.button === 1) { 
                isDraggingCanvas = true;
                lastX = e.clientX;
                lastScrollLeft = canvasContainer.scrollLeft;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvasContainer.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
            canvas.style.cursor = 'crosshair';
        });

        canvasContainer.addEventListener('mousemove', e => {
            if (!isDraggingCanvas) return;
            e.preventDefault();
            const dx = e.clientX - lastX;
            canvasContainer.scrollLeft = lastScrollLeft - dx;
        });

        canvasContainer.addEventListener('mouseleave', () => {
            isDraggingCanvas = false;
            canvas.style.cursor = 'crosshair';
        });

        updateCanvasBtn.addEventListener("click", () => {
            const newViewWidth = Math.max(100, parseInt(viewWidthInput.value) || 1280);
            const newLongWidth = Math.max(100, parseInt(longWidthInput.value) || 1280);
            const newHeight = Math.max(100, parseInt(heightInput.value) || 720);

            if (newLongWidth !== w || newHeight !== h) {
                const oldW = w;
                const oldH = h;

                // 更新畫布尺寸
                w = newLongWidth;
                h = newHeight;
                canvasContainer.style.width = `${newViewWidth}px`;
                canvasContainer.style.height = `${newHeight}px`;
                canvas.width = w;
                canvas.height = h;

                // 更新全畫布端點，只改 Y 值和 X 端點位置，不重置中間點
                const leftEnd = globalPoints.find(p => p.id === 0) || { id: 0 };
                const rightEnd = globalPoints.find(p => p.id === 1) || { id: 1 };
                const midY = h / 2;

                leftEnd.x = 0;
                leftEnd.y = midY;
                leftEnd.gray = 255;
                leftEnd.alpha = 255;

                rightEnd.x = w;
                rightEnd.y = midY;
                rightEnd.gray = 0;
                rightEnd.alpha = 255;

                if (!globalPoints.includes(leftEnd)) globalPoints.push(leftEnd);
                if (!globalPoints.includes(rightEnd)) globalPoints.push(rightEnd);


                // 調整矩形模式下的點
                const newRectHeight = h / RECT_COUNT;
                rectangles.forEach(rect => {
                    const newMidY = rect.rectStart.y + newRectHeight / 2;

                    const leftEnd = rect.linearGradientPoints.find(p => p.id === 0);
                    const rightEnd = rect.linearGradientPoints.find(p => p.id === 1);

                    if (leftEnd) {
                        leftEnd.x = 0;
                        leftEnd.y = newMidY;
                    }
                    if (rightEnd) {
                        rightEnd.x = w;
                        rightEnd.y = newMidY;
                    }

                    // 中間點只更新 Y 值，保留 X 值
                    rect.linearGradientPoints.forEach(p => {
                        if (p.id !== 0 && p.id !== 1) {
                            p.y = newMidY;
                        }
                    });
                });

                // 刷新畫面，但不重置模式或存檔
                setMode(currentMode, false);
                drawField();
                createSideLabels();
            }
        });


        saveBtn.addEventListener("click", () => {
            drawField(true);
            const image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
            saveBtn.setAttribute("href", image);
            saveBtn.setAttribute("download", "grayscale_gradient.png");
            drawField();
        });

        fullCanvasModeBtn.addEventListener("click", () => {
            setMode('full');
        });

        rectModeBtn.addEventListener("click", () => {
            setMode('rect');
        });

        let didDrag = false;

        function getMouseCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            return { mouseX, mouseY };
        }


        canvas.addEventListener("mousedown", e => {
            if (isDraggingCanvas) return;
            const { mouseX, mouseY } = getMouseCoords(e);
            didDrag = false;

            if (currentMode === 'full') {
                let foundPoint = null;
                for (let i = 0; i < globalPoints.length; i++) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }
                if (e.button === 0) {
                    if (foundPoint) {
                        draggingPoint = foundPoint;
                        selectedPoint = foundPoint;
                        canvas.style.cursor = "move";
                    } else {
                        const { gray: newGray, alpha: newAlpha } = calculateLinearGradientWithAlpha(globalPoints, mouseX, mouseY);
                        const newPoint = { x: mouseX, y: mouseY, gray: newGray, alpha: 255, id: pointIdCounter++ };
                        globalPoints.push(newPoint);
                        selectedPoint = newPoint;
                        saveState();
                    }
                }
                updateControls();
                drawField();
                return;
            }

            if (currentMode === 'rect') {
                const rectHeight = h / RECT_COUNT;
                const rectIndex = Math.floor(mouseY / rectHeight);
                const rectObj = rectangles[rectIndex];

                if (rectObj) {
                    selectedRectId = rectObj.id;
                    const rectPoints = rectObj.linearGradientPoints;

                    let foundPointToDrag = null;
                    for (let i = 0; i < rectPoints.length; i++) {
                        const p = rectPoints[i];
                        const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                        if (dist < 10) {
                            foundPointToDrag = p;
                            break;
                        }
                    }

                    if (e.button === 0) {
                        if (foundPointToDrag) {
                            draggingPoint = foundPointToDrag;
                            selectedPoint = foundPointToDrag;
                            canvas.style.cursor = "move";
                        } else {
                            const { gray: newGray, alpha: newAlpha } = calculateLinearGradientWithAlpha(globalPoints, mouseX, mouseY);
                            const newPoint = { x: mouseX, y: rectPoints[0].y, gray: newGray, alpha: 255, id: pointIdCounter++ };
                            rectPoints.push(newPoint);
                            selectedPoint = newPoint;
                            saveState();
                        }
                    }
                    updateControls();
                    drawField();
                } else {
                    selectedRectId = null;
                    selectedPoint = null;
                    updateControls();
                    drawField();
                }
            }
        });

        function throttleDraw() {
            if (!throttleTimeout) {
                throttleTimeout = setTimeout(() => {
                    drawField();
                    updateControls();
                    throttleTimeout = null;
                }, THROTTLE_DELAY);
            }
        }

        canvas.addEventListener("mousemove", e => {
            if (isDraggingCanvas) return;
            const { mouseX, mouseY } = getMouseCoords(e);
            if (draggingPoint) {
                didDrag = true;
                if (currentMode === 'full') {
                    const isEndPoint = (Math.abs(draggingPoint.x - 0) < 0.01) || (Math.abs(draggingPoint.x - w) < 0.01);
                    
                    if (isEndPoint) {
                        draggingPoint.y = mouseY;
                    } else {
                        draggingPoint.x = mouseX;
                        draggingPoint.y = mouseY;
                    }
                } else if (currentMode === 'rect' && selectedRectId !== null) {
                    const selectedRect = rectangles.find(r => r.id === selectedRectId);
                    const isFixedPoint = Math.abs(draggingPoint.x - 0) < 0.01 || Math.abs(draggingPoint.x - w) < 0.01;
                    if (!isFixedPoint) {
                        draggingPoint.x = Math.max(0, Math.min(mouseX, w));
                    }
                    draggingPoint.y = selectedRect.linearGradientPoints[0].y;
                }
                throttleDraw();
            }
        });

        canvas.addEventListener("mouseup", e => {
            if (isDraggingCanvas) return;
            if (draggingPoint) {
                if (didDrag) {
                    saveState();
                }
            }
            draggingPoint = null;
            canvas.style.cursor = "crosshair";
            didDrag = false;
            drawField();
            updateControls();
        });

        canvas.addEventListener("click", e => {
            if (isDraggingCanvas) return;
            if (didDrag) {
                didDrag = false;
                return;
            }
            const { mouseX, mouseY } = getMouseCoords(e);

            if (currentMode === 'full') {
                let foundPoint = null;
                for (let i = 0; i < globalPoints.length; i++) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }
                selectedPoint = foundPoint;
                updateControls();
                drawField();
                return;
            }

            if (currentMode === 'rect' && selectedRectId !== null) {
                const selectedRect = rectangles.find(r => r.id === selectedRectId);
                const rectPoints = selectedRect.linearGradientPoints;
                let foundPoint = null;
                for (let i = 0; i < rectPoints.length; i++) {
                    const p = rectPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    if (dist < 10) {
                        foundPoint = p;
                        break;
                    }
                }
                selectedPoint = foundPoint;
                updateControls();
                drawField();
            }
        });

        canvas.addEventListener("contextmenu", e => {
            e.preventDefault();
            const { mouseX, mouseY } = getMouseCoords(e);

            if (currentMode === 'full') {
                for (let i = globalPoints.length - 1; i >= 0; i--) {
                    const p = globalPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    const isEndPoint = (Math.abs(p.x - 0) < 0.01 || Math.abs(p.x - w) < 0.01);
                    
                    if (dist < 10 && !isEndPoint) {
                        globalPoints.splice(i, 1);
                        if (selectedPoint && selectedPoint.id === p.id) {
                            selectedPoint = null;
                        }
                        saveState();
                        updateControls();
                        drawField();
                        return;
                    }
                }
                return;
            }

            if (currentMode === 'rect' && selectedRectId !== null) {
                const selectedRect = rectangles.find(r => r.id === selectedRectId);
                if (!selectedRect) return;
                const rectPoints = selectedRect.linearGradientPoints;
                for (let i = rectPoints.length - 1; i >= 0; i--) {
                    const p = rectPoints[i];
                    const dist = Math.sqrt((mouseX - p.x) ** 2 + (mouseY - p.y) ** 2);
                    const isFixedPoint = Math.abs(p.x - 0) < 0.01 || Math.abs(p.x - w) < 0.01;
                    if (dist < 10 && !isFixedPoint) {
                        rectPoints.splice(i, 1);
                        if (selectedPoint && selectedPoint.id === p.id) {
                            selectedPoint = null;
                        }
                        saveState();
                        updateControls();
                        drawField();
                        return;
                    }
                }
            }
        });

        // 初始化
        initializeGlobalPoints();
        initializeRectangles();
        setMode('full', false);
        createSideLabels();
        saveState();


    </script>
</body>
</html>