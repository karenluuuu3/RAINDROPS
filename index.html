<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <title>RAINDROPS</title>
    <style>
        body {
            background: #222;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-family: sans-serif;
            padding: 20px;
        }

        .main-layout {
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        .canvas-container {
            width: 1280px;
            height: 720px;
            overflow-x: auto;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: crosshair;
            position: relative;
        }

        canvas {
            display: block;
        }

        .mode-buttons {
            margin-top: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 8px 15px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mode-button.active {
            background-color: #007bff;
        }
        
        .mode-button:hover:not(.active) {
            background-color: #555;
        }

        .video-mode-button {
            background-color: #e74c3c !important;
        }

        .video-mode-button.active {
            background-color: #c0392b !important;
        }

        .controls-container {
            margin-top: 0; 
            display: flex;
            gap: 20px;
        }

        .controls {
            width: 400px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .video-controls-content {
            background: #2c3e50;
            border: 2px solid #e74c3c;
        }

        .video-download-button {
            background-color: #8e44ad !important;
            font-size: 16px;
            width: 100%;
            margin: 5px 0;
        }

        .video-download-button:hover {
            background-color: #7d3c98 !important;
        }

        .video-download-button:disabled {
            background-color: #555 !important;
            cursor: not-allowed;
        }

        .point-control {
            margin: 5px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .point-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .point-control-row span:first-child {
            min-width: 60px;
        }

        .value-display {
            min-width: 40px;
            text-align: right;
            font-family: monospace;
            font-weight: bold;
            color: #33ccff;
            font-size: 20px;
        }
        .point-label {
            min-width: 60px;
        }

        input[type="range"] {
            flex: 1;
        }

        input[type="number"] {
            width: 80px;
        }

        .main-actions {
            margin-top: 15px;
            text-align: center;
        }

        .main-actions button, .main-actions a {
            padding: 10px 20px;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            text-decoration: none;
            display: inline-block;
            transition: background-color 0.2s;
        }

        .main-actions button:hover, .main-actions a:hover {
            background-color: #666;
        }

        .canvas-size-controls {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .side-label {
            padding: 0 5px;
            cursor: pointer;
            transition: color 0.2s, transform 0.2s;
            user-select: none;
        }

        .side-label:hover {
            transform: scale(1.1);
        }

        .side-label.unlocked {
            color: #33ccff;
            font-weight: bold;
        }

        .video-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .video-control-row label {
            min-width: 80px;
            font-size: 14px;
        }

        .video-control-row input {
            background: #34495e;
            border: 1px solid #555;
            color: white;
            padding: 5px;
            border-radius: 3px;
        }

        .video-play-button {
            background-color: #27ae60 !important;
            font-size: 18px;
            min-width: 120px;
        }

        .video-play-button:hover {
            background-color: #229954 !important;
        }

        .video-play-button.playing {
            background-color: #e74c3c !important;
        }

        .video-play-button.playing:hover {
            background-color: #c0392b !important;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #555;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: #e74c3c;
            width: 0%;
            transition: width 0.1s linear;
        }

        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: #ecf0f1;
            text-align: center;
            margin: 5px 0;
        }
    </style>
</head>

<body>
    <div class="mode-buttons">
        <button id="full-canvas-mode-btn" class="mode-button active">ÂÖ®Áï´Â∏É</button>
        <button id="rect-mode-btn" class="mode-button">Áü©ÂΩ¢Ê®°Âºè</button>
        <button id="video-mode-btn" class="mode-button video-mode-button">ÂΩ±ÁâáÊ®°Âºè</button>
    </div>

    <div class="canvas-size-controls">
        <label for="viewWidthInput">Â∑•‰ΩúÂçÄÂØ¨Â∫¶:</label>
        <input type="number" id="viewWidthInput" value="1280" min="100">
        <label for="longWidthInput">Á∏ΩËª∏Èï∑Â∫¶:</label>
        <input type="number" id="longWidthInput" value="1280" min="100">
        <label for="heightInput">Á∏ΩËª∏È´òÂ∫¶:</label>
        <input type="number" id="heightInput" value="720" min="100">
        <button id="update-canvas-btn">Êõ¥Êñ∞Áï´Â∏É</button>
    </div>

    <div class="main-layout">
        
        <div>
            <div style="display: flex; align-items: flex-start;">
                <div id="left-labels" style="width: 40px; text-align: right; color: white;"></div>
                <div class="canvas-container" id="canvas-container">
                    <canvas id="canvas" width="1280" height="720"></canvas>
                </div>
                <div id="right-labels" style="width: 40px; color: white;"></div>
            </div>
            <div class="main-actions">
                <a id="save-btn" href="#">ÂÑ≤Â≠òÂúñÁâá</a>
            </div>
        </div>

        <div class="controls-container">
            <div class="controls" id="controls-panel">
                <!-- Normal mode: points controls -->
                <div id="points-controls">
                    <h4>ÊéßÂà∂ÈªûÂ±¨ÊÄß</h4>
                    <div id="controls"></div>
                </div>

                <!-- Video mode: video controls -->
                <div class="video-controls-content" id="video-controls" style="display: none;">
                    <h4>üé¨ ÂΩ±ÁâáÊéßÂà∂</h4>
                    
                    <div class="video-control-row">
                        <label for="duration-input">Á∏ΩÊôÇÈï∑(Áßí):</label>
                        <input type="number" id="duration-input" value="10" min="1" max="300">
                    </div>
                    
                    <div class="video-control-row">
                        <label for="fps-input">FPS:</label>
                        <input type="number" id="fps-input" value="30" min="1" max="60">
                    </div>

                    <div class="video-control-row">
                        <label>Á∏ΩÂπÄÊï∏:</label>
                        <span id="total-frames-display">300</span>
                    </div>

                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>

                    <div class="time-display" id="time-display">00:00 / 10:00</div>

                    <div class="video-control-row">
                        <button id="video-play-btn" class="video-play-button">‚ñ∂ Êí≠Êîæ</button>
                        <button id="video-reset-btn" class="mode-button">ÈáçÁΩÆ</button>
                    </div>

                    <div class="video-control-row">
                        <button id="video-download-btn" class="video-download-button">üì• ‰∏ãËºâÂΩ±Áâá</button>
                    </div>

                    <div class="video-control-row">
                        <label for="current-frame-input">Áï∂ÂâçÂπÄ:</label>
                        <input type="number" id="current-frame-input" value="0" min="0">
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script>
    (() => {
        // ---- Constants ----
        const RECT_COUNT = 50;
        const MAX_HISTORY = 50;
        const POINT_RADIUS = 5;
        const HIT_RADIUS = 10;

        // ---- DOM Elements ----
        const canvasContainer = document.getElementById("canvas-container");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const viewWidthInput = document.getElementById("viewWidthInput");
        const longWidthInput = document.getElementById("longWidthInput");
        const heightInput = document.getElementById("heightInput");
        const updateCanvasBtn = document.getElementById("update-canvas-btn");
        const controlsDiv = document.getElementById("controls");
        const saveBtn = document.getElementById("save-btn");
        const fullCanvasModeBtn = document.getElementById("full-canvas-mode-btn");
        const rectModeBtn = document.getElementById("rect-mode-btn");
        const videoModeBtn = document.getElementById("video-mode-btn");
        const leftLabels = document.getElementById('left-labels');
        const rightLabels = document.getElementById('right-labels');

        // Video mode elements
        const videoControls = document.getElementById("video-controls");
        const durationInput = document.getElementById("duration-input");
        const fpsInput = document.getElementById("fps-input");
        const totalFramesDisplay = document.getElementById("total-frames-display");
        const progressFill = document.getElementById("progress-fill");
        const timeDisplay = document.getElementById("time-display");
        const videoPlayBtn = document.getElementById("video-play-btn");
        const videoResetBtn = document.getElementById("video-reset-btn");
        const videoDownloadBtn = document.getElementById("video-download-btn");
        const currentFrameInput = document.getElementById("current-frame-input");

        // ---- State ----
        let w = canvas.width;
        let h = canvas.height;
        let globalPoints = [];
        let rectangles = [];
        let pointIdCounter = 0;
        let currentMode = 'full';
        
        let draggingPoint = null;
        let selectedPoint = null;
        let selectedRectId = null;
        
        let history = [];
        let historyIndex = -1;
        
        let didDrag = false;
        let needsRedraw = true;
        let isDraggingCanvas = false;
        let lastDragX = 0;

        let temporaryPoint = null;
        let tempPointAssociatedRectId = null; 

        let unlockedRectId = null;

        // Video mode state
        let videoState = {
            isPlaying: false,
            currentFrame: 0,
            duration: 10,
            fps: 30,
            animationId: null,
            startTime: null
        };

        // ---- Video Download Functions ----
        async function downloadVideo() {
            console.log('Download video started');
            const totalFrames = videoState.duration * videoState.fps;
            
            // Disable the download button during processing
            videoDownloadBtn.disabled = true;
            videoDownloadBtn.textContent = "Ê≠£Âú®ËôïÁêÜ...";
            
            try {
                // Create a canvas for recording at fixed 1280x720 resolution
                const recordCanvas = document.createElement('canvas');
                recordCanvas.width = 1280;
                recordCanvas.height = 720;
                const recordCtx = recordCanvas.getContext('2d');
                
                // Store original UI function
                const originalDrawUI = window.drawUI;
                window.drawUI = () => {}; // Disable UI during recording
                
                const frames = [];
                
                // Generate all frames
                for (let frame = 0; frame < totalFrames; frame++) {
                    // Update progress
                    videoDownloadBtn.textContent = `ËôïÁêÜ‰∏≠... ${Math.round((frame / totalFrames) * 100)}%`;
                    
                    // Calculate scroll position for this frame
                    const scrollProgress = frame / Math.max(1, totalFrames - 1);
                    const maxScroll = Math.max(0, w - 1280);
                    const scrollPosition = scrollProgress * maxScroll;
                    
                    // Clear record canvas
                    recordCtx.clearRect(0, 0, 1280, 720);
                    
                    // Save context and translate for scroll effect
                    recordCtx.save();
                    recordCtx.translate(-scrollPosition, 0);
                    
                    // Draw global gradient to record canvas
                    drawNativeGradientToCanvas(recordCtx, globalPoints, { x: 0, y: 0, w, h });
                    
                    // Draw rectangle gradients to record canvas
                    rectangles.forEach(rect => {
                        const hasEffect = rect.points.some(p => p.alpha > 0);
                        if (rect.points.length > 2 || hasEffect) {
                            drawNativeGradientToCanvas(recordCtx, rect.points, { x: 0, y: rect.y, w, h: rect.height });
                        }
                    });
                    
                    recordCtx.restore();
                    
                    // Convert to blob and store
                    const frameData = await new Promise(resolve => {
                        recordCanvas.toBlob(resolve, 'image/png');
                    });
                    frames.push(frameData);
                    
                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
                
                // Restore UI function
                window.drawUI = originalDrawUI;
                requestDraw();
                
                // Download frames
                videoDownloadBtn.textContent = "‰∏ãËºâÂπÄÊ™îÊ°à...";
                await downloadFramesAsZip(frames);
                
            } catch (error) {
                console.error('Video download error:', error);
                alert('ÂΩ±Áâá‰∏ãËºâÂ§±Êïó: ' + error.message);
            } finally {
                // Re-enable button
                videoDownloadBtn.disabled = false;
                videoDownloadBtn.textContent = "üì• ‰∏ãËºâÂΩ±Áâá";
            }
        }
        
        function drawNativeGradientToCanvas(context, points, bounds) {
            if (points.length < 2) return;

            const sortedByX = [...points].sort((a, b) => a.x - b.x);
            const pStart = sortedByX[0];
            const pEnd = sortedByX[sortedByX.length - 1];

            const dx = pEnd.x - pStart.x;
            const dy = pEnd.y - pStart.y;
            const lenSq = dx * dx + dy * dy;

            if (lenSq === 0) return;

            const gradient = context.createLinearGradient(pStart.x, pStart.y, pEnd.x, pEnd.y);
            
            const projectedPoints = points.map(p => {
                const t = ((p.x - pStart.x) * dx + (p.y - pStart.y) * dy) / lenSq;
                return { ...p, t: Math.max(0, Math.min(1, t)) };
            }).sort((a, b) => a.t - b.t);

            projectedPoints.forEach(p => {
                gradient.addColorStop(p.t, `rgba(${p.gray}, ${p.gray}, ${p.gray}, ${p.alpha / 255})`);
            });
            
            context.fillStyle = gradient;
            context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
        }
        
        async function downloadFramesAsZip(frames) {
            const totalFrames = frames.length;
            const padLength = totalFrames.toString().length;
            
            // Download each frame individually
            for (let i = 0; i < frames.length; i++) {
                const frameNumber = (i + 1).toString().padStart(padLength, '0');
                const url = URL.createObjectURL(frames[i]);
                const link = document.createElement('a');
                link.href = url;
                link.download = `frame_${frameNumber}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                // Small delay between downloads to avoid browser issues
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            alert(`ÂΩ±ÁâáÂ∑≤‰∏ãËºâÁÇ∫ ${totalFrames} ÂÄã 1280x720 PNGÂπÄÊ™îÊ°à„ÄÇ\n\n‰ΩøÁî® FFmpeg ËΩâÊèõÁÇ∫ÂΩ±ÁâáÔºö\nffmpeg -framerate ${videoState.fps} -i frame_%0${padLength}d.png -c:v libx264 -pix_fmt yuv420p -s 1280x720 output.mp4`);
        }

        // ---- Video Mode Functions ----
        function updateVideoParams() {
            videoState.duration = parseInt(durationInput.value);
            videoState.fps = parseInt(fpsInput.value);
            const totalFrames = videoState.duration * videoState.fps;
            totalFramesDisplay.textContent = totalFrames;
            currentFrameInput.max = totalFrames - 1;
            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            const currentTime = videoState.currentFrame / videoState.fps;
            const totalTime = videoState.duration;
            const current = formatTime(currentTime);
            const total = formatTime(totalTime);
            timeDisplay.textContent = `${current} / ${total}`;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateVideoProgress() {
            const totalFrames = videoState.duration * videoState.fps;
            const progress = (videoState.currentFrame / Math.max(1, totalFrames - 1)) * 100;
            progressFill.style.width = `${Math.min(100, progress)}%`;
            currentFrameInput.value = videoState.currentFrame;
            updateTimeDisplay();
            
            // Calculate scroll position based on current frame
            const totalFrames_calc = videoState.duration * videoState.fps;
            const scrollProgress = videoState.currentFrame / Math.max(1, totalFrames_calc - 1);
            const maxScroll = Math.max(0, w - 1280);
            const scrollPosition = scrollProgress * maxScroll;
            canvasContainer.scrollLeft = scrollPosition;
        }

        function playVideo() {
            if (videoState.isPlaying) {
                stopVideo();
                return;
            }

            videoState.isPlaying = true;
            videoState.startTime = performance.now();
            videoPlayBtn.textContent = "‚è∏ Êö´ÂÅú";
            videoPlayBtn.classList.add("playing");

            function animate(currentTime) {
                if (!videoState.isPlaying) return;

                const elapsed = (currentTime - videoState.startTime) / 1000;
                videoState.currentFrame = Math.floor(elapsed * videoState.fps);
                
                const totalFrames = videoState.duration * videoState.fps;
                
                if (videoState.currentFrame >= totalFrames) {
                    videoState.currentFrame = totalFrames - 1;
                    stopVideo();
                    return;
                }

                updateVideoProgress();
                videoState.animationId = requestAnimationFrame(animate);
            }

            videoState.animationId = requestAnimationFrame(animate);
        }

        function stopVideo() {
            videoState.isPlaying = false;
            if (videoState.animationId) {
                cancelAnimationFrame(videoState.animationId);
                videoState.animationId = null;
            }
            videoPlayBtn.textContent = "‚ñ∂ Êí≠Êîæ";
            videoPlayBtn.classList.remove("playing");
        }

        function resetVideo() {
            stopVideo();
            videoState.currentFrame = 0;
            canvasContainer.scrollLeft = 0;
            updateVideoProgress();
        }

        function setVideoFrame(frame) {
            const totalFrames = videoState.duration * videoState.fps;
            videoState.currentFrame = Math.max(0, Math.min(frame, totalFrames - 1));
            updateVideoProgress();
        }

        // ---- State Management ----
        function saveState() {
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            const state = {
                globalPoints: JSON.parse(JSON.stringify(globalPoints)),
                rectangles: JSON.parse(JSON.stringify(rectangles))
            };
            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            historyIndex = history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const prevState = JSON.parse(JSON.stringify(history[historyIndex]));
                globalPoints = prevState.globalPoints;
                rectangles = prevState.rectangles;
                
                selectedPoint = null;
                requestDraw();
                updateControls();
            }
        }

        function commitTemporaryPoint() {
            if (!temporaryPoint) return;

            if (currentMode === 'full') {
                globalPoints.push(temporaryPoint);
            } else if (currentMode === 'rect' && tempPointAssociatedRectId !== null) {
                const rect = rectangles[tempPointAssociatedRectId];
                if (rect) {
                    rect.points.push(temporaryPoint);
                }
            }
            
            saveState();
            temporaryPoint = null;
            tempPointAssociatedRectId = null;
        }

        // ---- Initialization ----
        function initialize() {
            initializeGlobalPoints();
            initializeRectangles();
            createSideLabels();
            setupEventListeners();
            setMode('full', false);
            updateVideoParams();
            saveState();
            draw();
        }

        function initializeGlobalPoints() {
            pointIdCounter = 0;
            globalPoints = [
                { x: 0, y: h / 2, gray: 0, alpha: 0, id: pointIdCounter++ },
                { x: w, y: h / 2, gray: 0, alpha: 0, id: pointIdCounter++ }
            ];
            if (globalPoints.length > 0) {
                selectedPoint = globalPoints[0];
            }
        }

        function initializeRectangles() {
            rectangles = [];
            const rectHeight = h / RECT_COUNT;
            for (let i = 0; i < RECT_COUNT; i++) {
                const rectY = i * rectHeight;
                const rectMidY = rectY + rectHeight / 2;
                rectangles.push({
                    id: i,
                    y: rectY,
                    height: rectHeight,
                    points: [
                        { x: 0, y: rectMidY, gray: 0, alpha: 0, id: pointIdCounter++ },
                        { x: w, y: rectMidY, gray: 0, alpha: 0, id: pointIdCounter++ }
                    ]
                });
            }
        }

        // ---- Drawing Engine (Optimized) ----
        function requestDraw() {
            if (!needsRedraw) {
                needsRedraw = true;
                requestAnimationFrame(draw);
            }
        }
        
        function draw() {
            if (!needsRedraw) return;

            ctx.clearRect(0, 0, w, h);
            
            drawNativeGradient(globalPoints, { x: 0, y: 0, w, h });

            rectangles.forEach(rect => {
                const hasEffect = rect.points.some(p => p.alpha > 0);
                if (rect.points.length > 2 || hasEffect) {
                     drawNativeGradient(rect.points, { x: 0, y: rect.y, w, h: rect.height });
                }
            });

            if (typeof window.drawUI === 'function') {
                window.drawUI();
            }
            
            needsRedraw = false;
        }

        function drawNativeGradient(points, bounds) {
            if (points.length < 2) return;

            const sortedByX = [...points].sort((a, b) => a.x - b.x);
            const pStart = sortedByX[0];
            const pEnd = sortedByX[sortedByX.length - 1];

            const dx = pEnd.x - pStart.x;
            const dy = pEnd.y - pStart.y;
            const lenSq = dx * dx + dy * dy;

            if (lenSq === 0) return;

            const gradient = ctx.createLinearGradient(pStart.x, pStart.y, pEnd.x, pEnd.y);
            
            const projectedPoints = points.map(p => {
                const t = ((p.x - pStart.x) * dx + (p.y - pStart.y) * dy) / lenSq;
                return { ...p, t: Math.max(0, Math.min(1, t)) };
            }).sort((a, b) => a.t - b.t);

            projectedPoints.forEach(p => {
                gradient.addColorStop(p.t, `rgba(${p.gray}, ${p.gray}, ${p.gray}, ${p.alpha / 255})`);
            });
            
            ctx.fillStyle = gradient;
            ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
        }
        
        window.drawUI = function() {
            // In video mode, don't draw UI elements to keep clean output
            if (currentMode === 'video') return;

            let pointsToDraw;
            if (currentMode === 'full') {
                pointsToDraw = [...globalPoints];
            } else if (currentMode === 'rect') {
                pointsToDraw = unlockedRectId !== null ? [...rectangles[unlockedRectId]?.points] : [];
            } else {
                pointsToDraw = [];
            }
            
            if (temporaryPoint) {
                if (currentMode === 'full') {
                    pointsToDraw.push(temporaryPoint);
                } else if (currentMode === 'rect' && unlockedRectId === tempPointAssociatedRectId) {
                    pointsToDraw.push(temporaryPoint);
                }
            }
            
            if (pointsToDraw.length > 1) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                const sorted = [...pointsToDraw].sort((a, b) => a.x - b.x);
                ctx.moveTo(sorted[0].x, sorted[0].y);
                for (let i = 1; i < sorted.length; i++) {
                    ctx.lineTo(sorted[i].x, sorted[i].y);
                }
                ctx.stroke();
            }

            pointsToDraw.forEach(p => {
                const isSelected = selectedPoint && selectedPoint.id === p.id;

                if (currentMode === 'rect' && unlockedRectId !== null) {
                    const rect = rectangles[unlockedRectId];
                    if (rect) {
                        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(p.x, rect.y - 10);
                        ctx.lineTo(p.x, rect.y + rect.height + 10 );
                        ctx.stroke();
                    }
                }

                ctx.fillStyle = `rgb(${p.gray}, ${p.gray}, ${p.gray})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = isSelected ? "red" : "#FFF";
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.stroke();
            });
        }

        // ---- UI Updates ----
        function handleLabelClick(e) {
            if (temporaryPoint) {
                temporaryPoint = null;
                tempPointAssociatedRectId = null;
            }

            if (currentMode !== 'rect') return;
            const id = parseInt(e.target.dataset.rectId);
            
            if (id === unlockedRectId) {
                unlockedRectId = null;
                selectedRectId = null;
            } else {
                unlockedRectId = id;
                selectedRectId = id;
            }

            selectedPoint = null; 
            updateControls();
            updateLabelStyles();
            requestDraw();
        }

        function updateLabelStyles() {
            const allLabels = document.querySelectorAll('.side-label');
            allLabels.forEach(label => {
                const id = parseInt(label.dataset.rectId);
                label.classList.toggle('unlocked', id === unlockedRectId);
            });
        }

        function updateControls() {
            if (currentMode === 'video') {
                controlsDiv.innerHTML = '<p>ÂΩ±ÁâáÊ®°Âºè:‰ΩøÁî®Âè≥ÂÅ¥ÂΩ±ÁâáÊéßÂà∂Èù¢Êùø</p>';
                return;
            }

            const pointsToUse = (currentMode === 'full') 
                ? globalPoints 
                : (selectedRectId !== null ? rectangles[selectedRectId]?.points : null);

            let pointIsVisible = selectedPoint && (
                (temporaryPoint && selectedPoint.id === temporaryPoint.id) || 
                (pointsToUse && pointsToUse.find(p => p.id === selectedPoint.id))
            );

            if (!pointIsVisible) {
                controlsDiv.innerHTML = '';
                return;
            }

            const p = selectedPoint;
            const controlWrapper = document.createElement("div");
            controlWrapper.className = "point-control";

            const labelText = (currentMode === 'rect' && selectedRectId !== null)
                ? `ÂçÄÂüü ${selectedRectId + 1} Èªû ${p.id}`
                : `Èªû ${p.id}`;

            // Â∞áÈÄèÊòéÂ∫¶ËΩâÊèõÁÇ∫ 0~1 ÁöÑÊ†ºÂºèÈ°ØÁ§∫
            const alphaDisplay = (p.alpha / 255).toFixed(2);

            controlWrapper.innerHTML = `
                <span class="point-label">${labelText} (${p.x.toFixed(0)},${p.y.toFixed(0)})</span>
                <div class="point-control-row">
                    <span>ÁÅ∞Â∫¶:</span>
                    <input type="range" min="0" max="255" value="${p.gray}" data-prop="gray">
                    <span class="value-display" data-value="gray">${p.gray}</span>
                </div>
                <div class="point-control-row">
                    <span>ÈÄèÊòéÂ∫¶:</span>
                    <input type="range" min="0" max="255" value="${p.alpha}" data-prop="alpha">
                    <span class="value-display" data-value="alpha">${alphaDisplay}</span>
                </div>
            `;

            controlWrapper.querySelectorAll('input[type="range"]').forEach(slider => {
                slider.oninput = () => {
                    const prop = slider.dataset.prop;
                    p[prop] = parseInt(slider.value);
                    const valueSpan = controlWrapper.querySelector(`span[data-value="${prop}"]`);
                    if (valueSpan) {
                        if (prop === 'alpha') {
                            // ÈÄèÊòéÂ∫¶È°ØÁ§∫ÁÇ∫ 0~1ÔºåÈúÄË¶ÅÈô§‰ª• 255
                            valueSpan.textContent = (parseInt(slider.value) / 255).toFixed(2);
                        } else {
                            // ÁÅ∞Â∫¶È°ØÁ§∫ÂéüÂßãÂÄº
                            valueSpan.textContent = slider.value;
                        }
                    }
                    requestDraw();
                };
                slider.onchange = () => {
                    if (temporaryPoint && selectedPoint && selectedPoint.id === temporaryPoint.id) {
                        commitTemporaryPoint();
                    } else {
                        saveState();
                    }
                };
            });

            controlsDiv.replaceChildren(controlWrapper);
        }

        function setMode(mode, doSaveState = true) {
            if (temporaryPoint) {
                temporaryPoint = null;
                tempPointAssociatedRectId = null;
            }

            // Stop video if switching away from video mode
            if (currentMode === 'video' && mode !== 'video') {
                stopVideo();
            }

            currentMode = mode;
            fullCanvasModeBtn.classList.toggle('active', mode === 'full');
            rectModeBtn.classList.toggle('active', mode === 'rect');
            videoModeBtn.classList.toggle('active', mode === 'video');
            
            selectedPoint = null;
            selectedRectId = null;
            
            unlockedRectId = null;
            updateLabelStyles();

            // Show/hide appropriate controls
            const pointsControls = document.getElementById('points-controls');
            const videoControls = document.getElementById('video-controls');
            
            if (mode === 'video') {
                pointsControls.style.display = 'none';
                videoControls.style.display = 'block';
            } else {
                pointsControls.style.display = 'block';
                videoControls.style.display = 'none';
            }
            
            // Disable canvas interaction in video mode
            if (mode === 'video') {
                canvas.style.pointerEvents = 'none';
                canvasContainer.style.cursor = 'default';
            } else {
                canvas.style.pointerEvents = 'auto';
                canvasContainer.style.cursor = 'crosshair';
            }

            if (doSaveState) saveState();
            
            updateControls();
            requestDraw();
        }

        function createSideLabels() {
            const rectHeight = h / RECT_COUNT;
            const leftFragment = document.createDocumentFragment();
            const rightFragment = document.createDocumentFragment();

            for (let i = 0; i < RECT_COUNT; i++) {
                const label = document.createElement('div');
                label.style.height = `${rectHeight}px`;
                label.style.lineHeight = `${rectHeight}px`;
                label.style.fontSize = '12px';
                label.textContent = i + 1;
                label.className = 'side-label';
                label.dataset.rectId = i;
                label.addEventListener('click', handleLabelClick);
                leftFragment.appendChild(label);
                rightFragment.appendChild(label.cloneNode(true));
            }
            leftLabels.replaceChildren(leftFragment);
            
            rightFragment.childNodes.forEach(node => node.addEventListener('click', handleLabelClick));
            rightLabels.replaceChildren(rightFragment);

            updateLabelStyles();
        }

        // ---- Event Handlers ----
        function setupEventListeners() {
            canvas.addEventListener("mousedown", handleMouseDown);
            canvas.addEventListener("mousemove", handleMouseMove);
            window.addEventListener("mouseup", handleMouseUp);
            canvas.addEventListener("contextmenu", handleContextMenu);
            canvas.addEventListener("click", handleClick);

            canvasContainer.addEventListener('mousedown', handleContainerDragStart);
            canvasContainer.addEventListener('mousemove', handleContainerDrag);
            window.addEventListener('mouseup', handleContainerDragEnd);
            canvasContainer.addEventListener('mouseleave', handleContainerDragEnd);
            
            fullCanvasModeBtn.addEventListener("click", () => setMode('full'));
            rectModeBtn.addEventListener("click", () => setMode('rect'));
            videoModeBtn.addEventListener("click", () => setMode('video'));
            updateCanvasBtn.addEventListener("click", handleUpdateCanvas);
            saveBtn.addEventListener("click", handleSaveImage);
            
            // Video mode event listeners
            durationInput.addEventListener('input', updateVideoParams);
            fpsInput.addEventListener('input', updateVideoParams);
            videoPlayBtn.addEventListener('click', playVideo);
            videoResetBtn.addEventListener('click', resetVideo);
            videoDownloadBtn.addEventListener('click', downloadVideo);
            currentFrameInput.addEventListener('input', (e) => {
                setVideoFrame(parseInt(e.target.value));
            });
            
            window.addEventListener('keydown', e => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                }
                
                // Video mode keyboard shortcuts
                if (currentMode === 'video') {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        playVideo();
                    } else if (e.key === 'r') {
                        e.preventDefault();
                        resetVideo();
                    }
                }
            });
        }
        
        function handleMouseDown(e) {
            if (currentMode === 'video') return;
            if (e.button !== 0) return;
            const { x, y } = getMouseCoords(e);
            didDrag = false;

            const pointToDrag = getPointAtCoords(x, y);

            if (temporaryPoint && pointToDrag?.id !== temporaryPoint.id) {
                temporaryPoint = null;
                tempPointAssociatedRectId = null;
            }

            if (pointToDrag) {
                draggingPoint = pointToDrag;
                selectedPoint = pointToDrag;
                canvas.style.cursor = "move";
            } else {
                const pixelData = ctx.getImageData(x, y, 1, 1).data;
                const newGrayValue = pixelData[0];
                let newPoint;

                if (currentMode === 'full') {
                    newPoint = { x, y, gray: newGrayValue, alpha: 255, id: pointIdCounter++ };
                    tempPointAssociatedRectId = null;
                } else if (currentMode === 'rect') {
                    const rectIndex = Math.floor(y / (h / RECT_COUNT));
                    
                    if (rectIndex !== unlockedRectId) {
                        selectedPoint = null;
                        requestDraw();
                        updateControls();
                        return; 
                    }

                    if (rectangles[rectIndex]) {
                        selectedRectId = rectIndex;
                        const rectMidY = rectangles[rectIndex].y + rectangles[rectIndex].height / 2;
                        newPoint = { x, y: rectMidY, gray: newGrayValue, alpha: 255, id: pointIdCounter++ };
                        tempPointAssociatedRectId = rectIndex;
                    }
                }

                if (newPoint) {
                    temporaryPoint = newPoint;
                    selectedPoint = newPoint;
                    draggingPoint = newPoint;
                }
            }
            updateControls();
            requestDraw();
        }

        function handleMouseMove(e) {
            if (currentMode === 'video') return;
            if (!draggingPoint) return;
            didDrag = true;
            const { x, y } = getMouseCoords(e);

            if (currentMode === 'full') {
                const isEndPoint = draggingPoint.id === 0 || draggingPoint.id === 1;
                draggingPoint.x = isEndPoint ? draggingPoint.x : Math.max(0, Math.min(w, x));
                draggingPoint.y = Math.max(0, Math.min(h, y));
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                const rect = rectangles[selectedRectId];
                const isFixedPoint = rect.points.findIndex(p => p.id === draggingPoint.id) < 2;
                if (!isFixedPoint) {
                    draggingPoint.x = Math.max(0, Math.min(w, x));
                }
            }
            updateControls();
            requestDraw();
        }

        function handleMouseUp() {
            if (currentMode === 'video') return;
            if (draggingPoint && didDrag) {
                if (temporaryPoint && draggingPoint.id === temporaryPoint.id) {
                    commitTemporaryPoint();
                } else {
                    saveState();
                }
            }
            draggingPoint = null;
            canvas.style.cursor = "crosshair";
        }
        
        function handleClick(e) {
            if (currentMode === 'video') return;
            if (didDrag) return;
            const { x, y } = getMouseCoords(e);
            
            const pointClicked = getPointAtCoords(x,y);
            
            if (currentMode === 'rect' && pointClicked) {
                 const rectIndex = Math.floor(y / (h / RECT_COUNT));
                 if (rectIndex === unlockedRectId) {
                    selectedRectId = rectIndex;
                 }
            }
            
            selectedPoint = pointClicked;
            
            if (currentMode === 'rect' && selectedPoint && selectedPoint.alpha === 0) {
                const originalDrawUI = window.drawUI;
                window.drawUI = () => {};
                needsRedraw = true;
                draw();

                const pixelData = ctx.getImageData(selectedPoint.x, selectedPoint.y, 1, 1).data;
                const sampledGray = pixelData[0];

                window.drawUI = originalDrawUI;

                selectedPoint.gray = sampledGray;
                selectedPoint.alpha = 255;
                
                saveState();
            }

            updateControls();
            requestDraw();
        }
        
        function handleContextMenu(e) {
            if (currentMode === 'video') return;
            e.preventDefault();
            const { x, y } = getMouseCoords(e);
            const pointToDelete = getPointAtCoords(x, y);

            if (!pointToDelete) return;
            
            if (temporaryPoint && pointToDelete.id === temporaryPoint.id) return;

            let pointsArray;
            if (currentMode === 'full') {
                if (pointToDelete.id === 0 || pointToDelete.id === 1) return;
                pointsArray = globalPoints;
            } else if (currentMode === 'rect' && selectedRectId !== null) {
                pointsArray = rectangles[selectedRectId].points;
                if (pointsArray.findIndex(p => p.id === pointToDelete.id) < 2) return;
            } else {
                return;
            }

            const index = pointsArray.findIndex(p => p.id === pointToDelete.id);
            if (index > -1) {
                pointsArray.splice(index, 1);
                if (selectedPoint && selectedPoint.id === pointToDelete.id) {
                    selectedPoint = null;
                }
                saveState();
                updateControls();
                requestDraw();
            }
        }

        function handleUpdateCanvas() {
            const newViewWidth = parseInt(viewWidthInput.value) || 1280;
            const newLongWidth = parseInt(longWidthInput.value) || 1280;
            const newHeight = parseInt(heightInput.value) || 720;
            
            const oldW = w;
            const isEnlarging = newLongWidth > oldW;

            if (newLongWidth === w && newHeight === h) return;
            
            w = newLongWidth;
            h = newHeight;
            
            canvasContainer.style.width = `${newViewWidth}px`;
            canvasContainer.style.height = `${newHeight}px`;
            canvas.width = w;
            canvas.height = h;

            const leftEndPoint = globalPoints.find(p => p.id === 0);
            if(leftEndPoint) leftEndPoint.y = h / 2;

            const rightEndPoint = globalPoints.find(p => p.id === 1);
            if(rightEndPoint) {
                if (isEnlarging) {
                    const newIntermediatePoint = {
                        x: oldW,
                        y: rightEndPoint.y,
                        gray: rightEndPoint.gray,
                        alpha: rightEndPoint.alpha,
                        id: pointIdCounter++
                    };
                    globalPoints.push(newIntermediatePoint);
                }
                rightEndPoint.x = w;
                rightEndPoint.y = h / 2;
            }

            const newRectHeight = h / RECT_COUNT;
            rectangles.forEach((rect, i) => {
                const newY = i * newRectHeight;
                const newMidY = newY + newRectHeight / 2;
                rect.y = newY;
                rect.height = newRectHeight;
                
                const rectRightEndPoint = rect.points[1];
                if (isEnlarging && rectRightEndPoint) {
                    const newIntermediatePoint = {
                        x: oldW,
                        y: newMidY,
                        gray: rectRightEndPoint.gray,
                        alpha: rectRightEndPoint.alpha,
                        id: pointIdCounter++
                    };
                    rect.points.push(newIntermediatePoint);
                }

                rect.points.forEach((p, index) => {
                    if (index === 0) p.x = 0;
                    if (index === 1) p.x = w;
                    p.y = newMidY;
                });
            });
            
            createSideLabels();
            saveState();
            requestDraw();
        }

        function handleSaveImage(e) {
            e.preventDefault();
            const originalDrawUI = window.drawUI;
            window.drawUI = () => {}; 
            needsRedraw = true;
            draw();
            
            const image = canvas.toDataURL("image/png");
            
            window.drawUI = originalDrawUI; 
            requestDraw();
            
            const link = document.createElement('a');
            link.href = image;
            link.download = "gradient.png";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function handleContainerDragStart(e) {
            if (currentMode === 'video') return;
            if (e.button === 1) {
                isDraggingCanvas = true;
                lastDragX = e.clientX;
                canvasContainer.style.cursor = 'grabbing';
                e.preventDefault();
            }
        }
        function handleContainerDrag(e) {
            if (currentMode === 'video') return;
            if (!isDraggingCanvas) return;
            const dx = e.clientX - lastDragX;
            canvasContainer.scrollLeft -= dx;
            lastDragX = e.clientX;
        }
        function handleContainerDragEnd() {
            if (currentMode === 'video') return;
            isDraggingCanvas = false;
            canvasContainer.style.cursor = 'crosshair';
        }

        // ---- Helpers ----
        function getMouseCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
            };
        }

        function getPointAtCoords(x, y) {
            if (temporaryPoint) {
                const rectIndex = (currentMode === 'rect') ? Math.floor(y / (h / RECT_COUNT)) : null;
                const isTempPointRelevant = (currentMode === 'full') || (currentMode === 'rect' && rectIndex === tempPointAssociatedRectId);
                
                if (isTempPointRelevant) {
                    const dist = Math.sqrt((x - temporaryPoint.x) ** 2 + (y - temporaryPoint.y) ** 2);
                    if (dist < HIT_RADIUS) {
                        return temporaryPoint;
                    }
                }
            }

            let pointsToSearch = [];
            if (currentMode === 'full') {
                pointsToSearch = globalPoints;
            } else if (currentMode === 'rect') {
                const rectIndex = Math.floor(y / (h / RECT_COUNT));
                if (rectIndex === unlockedRectId && rectangles[rectIndex]) {
                    pointsToSearch = rectangles[rectIndex].points;
                }
            }
            
            if (!pointsToSearch || !pointsToSearch.length) return null;

            let closestPoint = null;
            let minDistance = HIT_RADIUS;

            for (const p of pointsToSearch) {
                const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                if (dist < minDistance) {
                    minDistance = dist;
                    closestPoint = p;
                }
            }
            return closestPoint;
        }

        // ---- App Entry Point ----
        initialize();
    })();
</script>
</body>

</html>